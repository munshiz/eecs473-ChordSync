#pragma once

namespace web {
constexpr char const index_html_content[] = R"RAW(<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>ChordSync</title>    <link rel="stylesheet" href="compiled.css">    <script src="htmx.js"></script>    <script src="htmx.sse.js"></script>    <meta name="htmx-config" content='{        "responseHandling":[            {"code":"204", "swap": false},            {"code":"[23]..", "swap": true},            {"code":"422", "swap": true},            {"code":"504", "swap": true},            {"code":"[45]..", "swap": false, "error":true},            {"code":"...", "swap": true}        ]    }' /></head><body>    <div class="maxwidthcontainer min-h-screen">        <div id="error-popup" class="max-w-xl w-full fixed top-0.5 left-1/2 transform -translate-x-1/2 z-50"></div>        <div class="mt-6 mx-auto flex flex-col text-center items-center">            <h1 class="text-3xl font-bold mb-8">ChordSync</h1>            <div>                <h2 class="text-2xl font-semibold">Song Mode</h2>                <div class="mt-2">                    <h3 class="font-medium text-lg">Current song:</h3>                    <div hx-ext="sse" sse-connect="/song-info" sse-swap="message"></div>                </div>                <div id="song-form-container" hx-get="/song-select-form" hx-trigger="load" class="mt-4"></div>            </div>            <div class="mt-12">                <h2 class="text-2xl font-semibold">Practice Mode</h2>                <div class="mt-2">                    <h3 class="font-medium text-lg">Feedback:</h3>                    <div id="practice-feedback">                        No feedback yet!                    </div>                </div>                <div id="chord-form-container" hx-get="/chord-select-form" hx-trigger="load" class="mt-2"></div>            </div>        </div>    </div></body><footer class="rounded-lg shadow m-4 sticky bottom-2">    <div class="w-full mx-auto max-w-screen-xl p-4 flex items-center justify-between">        <p class="text-sm text-gray-500">An EECS 473 project by Hudson H, Zawad            M, Owen P, Akshaya R & Neel V</p>        <a class="text-sm font-medium text-gray-500" href="https://github.com/owenpark8/eecs473-VSGuitar"            target="_blank">Github</a>    </div></footer></html>)RAW";
constexpr char const htmx_min_js_content[] = R"RAW((function(e,t){if(typeof define==="function"&&define.amd){define([],t)}else if(typeof module==="object"&&module.exports){module.exports=t()}else{e.htmx=e.htmx||t()}})(typeof self!=="undefined"?self:this,function(){return function(){"use strict";var Q={onLoad:F,process:zt,on:de,off:ge,trigger:ce,ajax:Nr,find:C,findAll:f,closest:v,values:function(e,t){var r=dr(e,t||"post");return r.values},remove:_,addClass:z,removeClass:n,toggleClass:$,takeClass:W,defineExtension:Ur,removeExtension:Br,logAll:V,logNone:j,logger:null,config:{historyEnabled:true,historyCacheSize:10,refreshOnHistoryMiss:false,defaultSwapStyle:"innerHTML",defaultSwapDelay:0,defaultSettleDelay:20,includeIndicatorStyles:true,indicatorClass:"htmx-indicator",requestClass:"htmx-request",addedClass:"htmx-added",settlingClass:"htmx-settling",swappingClass:"htmx-swapping",allowEval:true,allowScriptTags:true,inlineScriptNonce:"",attributesToSettle:["class","style","width","height"],withCredentials:false,timeout:0,wsReconnectDelay:"full-jitter",wsBinaryType:"blob",disableSelector:"[hx-disable], [data-hx-disable]",useTemplateFragments:false,scrollBehavior:"smooth",defaultFocusScroll:false,getCacheBusterParam:false,globalViewTransitions:false,methodsThatUseUrlParams:["get"],selfRequestsOnly:false,ignoreTitle:false,scrollIntoViewOnBoost:true,triggerSpecsCache:null},parseInterval:d,_:t,createEventSource:function(e){return new EventSource(e,{withCredentials:true})},createWebSocket:function(e){var t=new WebSocket(e,[]);t.binaryType=Q.config.wsBinaryType;return t},version:"1.9.12"};var r={addTriggerHandler:Lt,bodyContains:se,canAccessLocalStorage:U,findThisElement:xe,filterValues:yr,hasAttribute:o,getAttributeValue:te,getClosestAttributeValue:ne,getClosestMatch:c,getExpressionVars:Hr,getHeaders:xr,getInputValues:dr,getInternalData:ae,getSwapSpecification:wr,getTriggerSpecs:it,getTarget:ye,makeFragment:l,mergeObjects:le,makeSettleInfo:T,oobSwap:Ee,querySelectorExt:ue,selectAndSwap:je,settleImmediately:nr,shouldCancel:ut,triggerEvent:ce,triggerErrorEvent:fe,withExtensions:R};var w=["get","post","put","delete","patch"];var i=w.map(function(e){return"[hx-"+e+"], [data-hx-"+e+"]"}).join(", ");var S=e("head"),q=e("title"),H=e("svg",true);function e(e,t){return new RegExp("<"+e+"(\\s[^>]*>|>)([\\s\\S]*?)<\\/"+e+">",!!t?"gim":"im")}function d(e){if(e==undefined){return undefined}let t=NaN;if(e.slice(-2)=="ms"){t=parseFloat(e.slice(0,-2))}else if(e.slice(-1)=="s"){t=parseFloat(e.slice(0,-1))*1e3}else if(e.slice(-1)=="m"){t=parseFloat(e.slice(0,-1))*1e3*60}else{t=parseFloat(e)}return isNaN(t)?undefined:t}function ee(e,t){return e.getAttribute&&e.getAttribute(t)}function o(e,t){return e.hasAttribute&&(e.hasAttribute(t)||e.hasAttribute("data-"+t))}function te(e,t){return ee(e,t)||ee(e,"data-"+t)}function u(e){return e.parentElement}function re(){return document}function c(e,t){while(e&&!t(e)){e=u(e)}return e?e:null}function L(e,t,r){var n=te(t,r);var i=te(t,"hx-disinherit");if(e!==t&&i&&(i==="*"||i.split(" ").indexOf(r)>=0)){return"unset"}else{return n}}function ne(t,r){var n=null;c(t,function(e){return n=L(t,e,r)});if(n!=="unset"){return n}}function h(e,t){var r=e.matches||e.matchesSelector||e.msMatchesSelector||e.mozMatchesSelector||e.webkitMatchesSelector||e.oMatchesSelector;return r&&r.call(e,t)}function A(e){var t=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i;var r=t.exec(e);if(r){return r[1].toLowerCase()}else{return""}}function s(e,t){var r=new DOMParser;var n=r.parseFromString(e,"text/html");var i=n.body;while(t>0){t--;i=i.firstChild}if(i==null){i=re().createDocumentFragment()}return i}function N(e){return/<body/.test(e)}function l(e){var t=!N(e);var r=A(e);var n=e;if(r==="head"){n=n.replace(S,"")}if(Q.config.useTemplateFragments&&t){var i=s("<body><template>"+n+"</template></body>",0);var a=i.querySelector("template").content;if(Q.config.allowScriptTags){oe(a.querySelectorAll("script"),function(e){if(Q.config.inlineScriptNonce){e.nonce=Q.config.inlineScriptNonce}e.htmxExecuted=navigator.userAgent.indexOf("Firefox")===-1})}else{oe(a.querySelectorAll("script"),function(e){_(e)})}return a}switch(r){case"thead":case"tbody":case"tfoot":case"colgroup":case"caption":return s("<table>"+n+"</table>",1);case"col":return s("<table><colgroup>"+n+"</colgroup></table>",2);case"tr":return s("<table><tbody>"+n+"</tbody></table>",2);case"td":case"th":return s("<table><tbody><tr>"+n+"</tr></tbody></table>",3);case"script":case"style":return s("<div>"+n+"</div>",1);default:return s(n,0)}}function ie(e){if(e){e()}}function I(e,t){return Object.prototype.toString.call(e)==="[object "+t+"]"}function k(e){return I(e,"Function")}function P(e){return I(e,"Object")}function ae(e){var t="htmx-internal-data";var r=e[t];if(!r){r=e[t]={}}return r}function M(e){var t=[];if(e){for(var r=0;r<e.length;r++){t.push(e[r])}}return t}function oe(e,t){if(e){for(var r=0;r<e.length;r++){t(e[r])}}}function X(e){var t=e.getBoundingClientRect();var r=t.top;var n=t.bottom;return r<window.innerHeight&&n>=0}function se(e){if(e.getRootNode&&e.getRootNode()instanceof window.ShadowRoot){return re().body.contains(e.getRootNode().host)}else{return re().body.contains(e)}}function D(e){return e.trim().split(/\s+/)}function le(e,t){for(var r in t){if(t.hasOwnProperty(r)){e[r]=t[r]}}return e}function E(e){try{return JSON.parse(e)}catch(e){b(e);return null}}function U(){var e="htmx:localStorageTest";try{localStorage.setItem(e,e);localStorage.removeItem(e);return true}catch(e){return false}}function B(t){try{var e=new URL(t);if(e){t=e.pathname+e.search}if(!/^\/$/.test(t)){t=t.replace(/\/+$/,"")}return t}catch(e){return t}}function t(e){return Tr(re().body,function(){return eval(e)})}function F(t){var e=Q.on("htmx:load",function(e){t(e.detail.elt)});return e}function V(){Q.logger=function(e,t,r){if(console){console.log(t,e,r)}}}function j(){Q.logger=null}function C(e,t){if(t){return e.querySelector(t)}else{return C(re(),e)}}function f(e,t){if(t){return e.querySelectorAll(t)}else{return f(re(),e)}}function _(e,t){e=p(e);if(t){setTimeout(function(){_(e);e=null},t)}else{e.parentElement.removeChild(e)}}function z(e,t,r){e=p(e);if(r){setTimeout(function(){z(e,t);e=null},r)}else{e.classList&&e.classList.add(t)}}function n(e,t,r){e=p(e);if(r){setTimeout(function(){n(e,t);e=null},r)}else{if(e.classList){e.classList.remove(t);if(e.classList.length===0){e.removeAttribute("class")}}}}function $(e,t){e=p(e);e.classList.toggle(t)}function W(e,t){e=p(e);oe(e.parentElement.children,function(e){n(e,t)});z(e,t)}function v(e,t){e=p(e);if(e.closest){return e.closest(t)}else{do{if(e==null||h(e,t)){return e}}while(e=e&&u(e));return null}}function g(e,t){return e.substring(0,t.length)===t}function G(e,t){return e.substring(e.length-t.length)===t}function J(e){var t=e.trim();if(g(t,"<")&&G(t,"/>")){return t.substring(1,t.length-2)}else{return t}}function Z(e,t){if(t.indexOf("closest ")===0){return[v(e,J(t.substr(8)))]}else if(t.indexOf("find ")===0){return[C(e,J(t.substr(5)))]}else if(t==="next"){return[e.nextElementSibling]}else if(t.indexOf("next ")===0){return[K(e,J(t.substr(5)))]}else if(t==="previous"){return[e.previousElementSibling]}else if(t.indexOf("previous ")===0){return[Y(e,J(t.substr(9)))]}else if(t==="document"){return[document]}else if(t==="window"){return[window]}else if(t==="body"){return[document.body]}else{return re().querySelectorAll(J(t))}}var K=function(e,t){var r=re().querySelectorAll(t);for(var n=0;n<r.length;n++){var i=r[n];if(i.compareDocumentPosition(e)===Node.DOCUMENT_POSITION_PRECEDING){return i}}};var Y=function(e,t){var r=re().querySelectorAll(t);for(var n=r.length-1;n>=0;n--){var i=r[n];if(i.compareDocumentPosition(e)===Node.DOCUMENT_POSITION_FOLLOWING){return i}}};function ue(e,t){if(t){return Z(e,t)[0]}else{return Z(re().body,e)[0]}}function p(e){if(I(e,"String")){return C(e)}else{return e}}function ve(e,t,r){if(k(t)){return{target:re().body,event:e,listener:t}}else{return{target:p(e),event:t,listener:r}}}function de(t,r,n){jr(function(){var e=ve(t,r,n);e.target.addEventListener(e.event,e.listener)});var e=k(r);return e?r:n}function ge(t,r,n){jr(function(){var e=ve(t,r,n);e.target.removeEventListener(e.event,e.listener)});return k(r)?r:n}var pe=re().createElement("output");function me(e,t){var r=ne(e,t);if(r){if(r==="this"){return[xe(e,t)]}else{var n=Z(e,r);if(n.length===0){b('The selector "'+r+'" on '+t+" returned no matches!");return[pe]}else{return n}}}}function xe(e,t){return c(e,function(e){return te(e,t)!=null})}function ye(e){var t=ne(e,"hx-target");if(t){if(t==="this"){return xe(e,"hx-target")}else{return ue(e,t)}}else{var r=ae(e);if(r.boosted){return re().body}else{return e}}}function be(e){var t=Q.config.attributesToSettle;for(var r=0;r<t.length;r++){if(e===t[r]){return true}}return false}function we(t,r){oe(t.attributes,function(e){if(!r.hasAttribute(e.name)&&be(e.name)){t.removeAttribute(e.name)}});oe(r.attributes,function(e){if(be(e.name)){t.setAttribute(e.name,e.value)}})}function Se(e,t){var r=Fr(t);for(var n=0;n<r.length;n++){var i=r[n];try{if(i.isInlineSwap(e)){return true}}catch(e){b(e)}}return e==="outerHTML"}function Ee(e,i,a){var t="#"+ee(i,"id");var o="outerHTML";if(e==="true"){}else if(e.indexOf(":")>0){o=e.substr(0,e.indexOf(":"));t=e.substr(e.indexOf(":")+1,e.length)}else{o=e}var r=re().querySelectorAll(t);if(r){oe(r,function(e){var t;var r=i.cloneNode(true);t=re().createDocumentFragment();t.appendChild(r);if(!Se(o,e)){t=r}var n={shouldSwap:true,target:e,fragment:t};if(!ce(e,"htmx:oobBeforeSwap",n))return;e=n.target;if(n["shouldSwap"]){Fe(o,e,e,t,a)}oe(a.elts,function(e){ce(e,"htmx:oobAfterSwap",n)})});i.parentNode.removeChild(i)}else{i.parentNode.removeChild(i);fe(re().body,"htmx:oobErrorNoTarget",{content:i})}return e}function Ce(e,t,r){var n=ne(e,"hx-select-oob");if(n){var i=n.split(",");for(var a=0;a<i.length;a++){var o=i[a].split(":",2);var s=o[0].trim();if(s.indexOf("#")===0){s=s.substring(1)}var l=o[1]||"true";var u=t.querySelector("#"+s);if(u){Ee(l,u,r)}}}oe(f(t,"[hx-swap-oob], [data-hx-swap-oob]"),function(e){var t=te(e,"hx-swap-oob");if(t!=null){Ee(t,e,r)}})}function Re(e){oe(f(e,"[hx-preserve], [data-hx-preserve]"),function(e){var t=te(e,"id");var r=re().getElementById(t);if(r!=null){e.parentNode.replaceChild(r,e)}})}function Te(o,e,s){oe(e.querySelectorAll("[id]"),function(e){var t=ee(e,"id");if(t&&t.length>0){var r=t.replace("'","\\'");var n=e.tagName.replace(":","\\:");var i=o.querySelector(n+"[id='"+r+"']");if(i&&i!==o){var a=e.cloneNode();we(e,i);s.tasks.push(function(){we(e,a)})}}})}function Oe(e){return function(){n(e,Q.config.addedClass);zt(e);Nt(e);qe(e);ce(e,"htmx:load")}}function qe(e){var t="[autofocus]";var r=h(e,t)?e:e.querySelector(t);if(r!=null){r.focus()}}function a(e,t,r,n){Te(e,r,n);while(r.childNodes.length>0){var i=r.firstChild;z(i,Q.config.addedClass);e.insertBefore(i,t);if(i.nodeType!==Node.TEXT_NODE&&i.nodeType!==Node.COMMENT_NODE){n.tasks.push(Oe(i))}}}function He(e,t){var r=0;while(r<e.length){t=(t<<5)-t+e.charCodeAt(r++)|0}return t}function Le(e){var t=0;if(e.attributes){for(var r=0;r<e.attributes.length;r++){var n=e.attributes[r];if(n.value){t=He(n.name,t);t=He(n.value,t)}}}return t}function Ae(e){var t=ae(e);if(t.onHandlers){for(var r=0;r<t.onHandlers.length;r++){const n=t.onHandlers[r];e.removeEventListener(n.event,n.listener)}delete t.onHandlers}}function Ne(e){var t=ae(e);if(t.timeout){clearTimeout(t.timeout)}if(t.webSocket){t.webSocket.close()}if(t.sseEventSource){t.sseEventSource.close()}if(t.listenerInfos){oe(t.listenerInfos,function(e){if(e.on){e.on.removeEventListener(e.trigger,e.listener)}})}Ae(e);oe(Object.keys(t),function(e){delete t[e]})}function m(e){ce(e,"htmx:beforeCleanupElement");Ne(e);if(e.children){oe(e.children,function(e){m(e)})}}function Ie(t,e,r){if(t.tagName==="BODY"){return Ue(t,e,r)}else{var n;var i=t.previousSibling;a(u(t),t,e,r);if(i==null){n=u(t).firstChild}else{n=i.nextSibling}r.elts=r.elts.filter(function(e){return e!=t});while(n&&n!==t){if(n.nodeType===Node.ELEMENT_NODE){r.elts.push(n)}n=n.nextElementSibling}m(t);u(t).removeChild(t)}}function ke(e,t,r){return a(e,e.firstChild,t,r)}function Pe(e,t,r){return a(u(e),e,t,r)}function Me(e,t,r){return a(e,null,t,r)}function Xe(e,t,r){return a(u(e),e.nextSibling,t,r)}function De(e,t,r){m(e);return u(e).removeChild(e)}function Ue(e,t,r){var n=e.firstChild;a(e,n,t,r);if(n){while(n.nextSibling){m(n.nextSibling);e.removeChild(n.nextSibling)}m(n);e.removeChild(n)}}function Be(e,t,r){var n=r||ne(e,"hx-select");if(n){var i=re().createDocumentFragment();oe(t.querySelectorAll(n),function(e){i.appendChild(e)});t=i}return t}function Fe(e,t,r,n,i){switch(e){case"none":return;case"outerHTML":Ie(r,n,i);return;case"afterbegin":ke(r,n,i);return;case"beforebegin":Pe(r,n,i);return;case"beforeend":Me(r,n,i);return;case"afterend":Xe(r,n,i);return;case"delete":De(r,n,i);return;default:var a=Fr(t);for(var o=0;o<a.length;o++){var s=a[o];try{var l=s.handleSwap(e,r,n,i);if(l){if(typeof l.length!=="undefined"){for(var u=0;u<l.length;u++){var f=l[u];if(f.nodeType!==Node.TEXT_NODE&&f.nodeType!==Node.COMMENT_NODE){i.tasks.push(Oe(f))}}}return}}catch(e){b(e)}}if(e==="innerHTML"){Ue(r,n,i)}else{Fe(Q.config.defaultSwapStyle,t,r,n,i)}}}function Ve(e){if(e.indexOf("<title")>-1){var t=e.replace(H,"");var r=t.match(q);if(r){return r[2]}}}function je(e,t,r,n,i,a){i.title=Ve(n);var o=l(n);if(o){Ce(r,o,i);o=Be(r,o,a);Re(o);return Fe(e,r,t,o,i)}}function _e(e,t,r){var n=e.getResponseHeader(t);if(n.indexOf("{")===0){var i=E(n);for(var a in i){if(i.hasOwnProperty(a)){var o=i[a];if(!P(o)){o={value:o}}ce(r,a,o)}}}else{var s=n.split(",");for(var l=0;l<s.length;l++){ce(r,s[l].trim(),[])}}}var ze=/\s/;var x=/[\s,]/;var $e=/[_$a-zA-Z]/;var We=/[_$a-zA-Z0-9]/;var Ge=['"',"'","/"];var Je=/[^\s]/;var Ze=/[{(]/;var Ke=/[})]/;function Ye(e){var t=[];var r=0;while(r<e.length){if($e.exec(e.charAt(r))){var n=r;while(We.exec(e.charAt(r+1))){r++}t.push(e.substr(n,r-n+1))}else if(Ge.indexOf(e.charAt(r))!==-1){var i=e.charAt(r);var n=r;r++;while(r<e.length&&e.charAt(r)!==i){if(e.charAt(r)==="\\"){r++}r++}t.push(e.substr(n,r-n+1))}else{var a=e.charAt(r);t.push(a)}r++}return t}function Qe(e,t,r){return $e.exec(e.charAt(0))&&e!=="true"&&e!=="false"&&e!=="this"&&e!==r&&t!=="."}function et(e,t,r){if(t[0]==="["){t.shift();var n=1;var i=" return (function("+r+"){ return (";var a=null;while(t.length>0){var o=t[0];if(o==="]"){n--;if(n===0){if(a===null){i=i+"true"}t.shift();i+=")})";try{var s=Tr(e,function(){return Function(i)()},function(){return true});s.source=i;return s}catch(e){fe(re().body,"htmx:syntax:error",{error:e,source:i});return null}}}else if(o==="["){n++}if(Qe(o,a,r)){i+="(("+r+"."+o+") ? ("+r+"."+o+") : (window."+o+"))"}else{i=i+o}a=t.shift()}}}function y(e,t){var r="";while(e.length>0&&!t.test(e[0])){r+=e.shift()}return r}function tt(e){var t;if(e.length>0&&Ze.test(e[0])){e.shift();t=y(e,Ke).trim();e.shift()}else{t=y(e,x)}return t}var rt="input, textarea, select";function nt(e,t,r){var n=[];var i=Ye(t);do{y(i,Je);var a=i.length;var o=y(i,/[,\[\s]/);if(o!==""){if(o==="every"){var s={trigger:"every"};y(i,Je);s.pollInterval=d(y(i,/[,\[\s]/));y(i,Je);var l=et(e,i,"event");if(l){s.eventFilter=l}n.push(s)}else if(o.indexOf("sse:")===0){n.push({trigger:"sse",sseEvent:o.substr(4)})}else{var u={trigger:o};var l=et(e,i,"event");if(l){u.eventFilter=l}while(i.length>0&&i[0]!==","){y(i,Je);var f=i.shift();if(f==="changed"){u.changed=true}else if(f==="once"){u.once=true}else if(f==="consume"){u.consume=true}else if(f==="delay"&&i[0]===":"){i.shift();u.delay=d(y(i,x))}else if(f==="from"&&i[0]===":"){i.shift();if(Ze.test(i[0])){var c=tt(i)}else{var c=y(i,x);if(c==="closest"||c==="find"||c==="next"||c==="previous"){i.shift();var h=tt(i);if(h.length>0){c+=" "+h}}}u.from=c}else if(f==="target"&&i[0]===":"){i.shift();u.target=tt(i)}else if(f==="throttle"&&i[0]===":"){i.shift();u.throttle=d(y(i,x))}else if(f==="queue"&&i[0]===":"){i.shift();u.queue=y(i,x)}else if(f==="root"&&i[0]===":"){i.shift();u[f]=tt(i)}else if(f==="threshold"&&i[0]===":"){i.shift();u[f]=y(i,x)}else{fe(e,"htmx:syntax:error",{token:i.shift()})}}n.push(u)}}if(i.length===a){fe(e,"htmx:syntax:error",{token:i.shift()})}y(i,Je)}while(i[0]===","&&i.shift());if(r){r[t]=n}return n}function it(e){var t=te(e,"hx-trigger");var r=[];if(t){var n=Q.config.triggerSpecsCache;r=n&&n[t]||nt(e,t,n)}if(r.length>0){return r}else if(h(e,"form")){return[{trigger:"submit"}]}else if(h(e,'input[type="button"], input[type="submit"]')){return[{trigger:"click"}]}else if(h(e,rt)){return[{trigger:"change"}]}else{return[{trigger:"click"}]}}function at(e){ae(e).cancelled=true}function ot(e,t,r){var n=ae(e);n.timeout=setTimeout(function(){if(se(e)&&n.cancelled!==true){if(!ct(r,e,Wt("hx:poll:trigger",{triggerSpec:r,target:e}))){t(e)}ot(e,t,r)}},r.pollInterval)}function st(e){return location.hostname===e.hostname&&ee(e,"href")&&ee(e,"href").indexOf("#")!==0}function lt(t,r,e){if(t.tagName==="A"&&st(t)&&(t.target===""||t.target==="_self")||t.tagName==="FORM"){r.boosted=true;var n,i;if(t.tagName==="A"){n="get";i=ee(t,"href")}else{var a=ee(t,"method");n=a?a.toLowerCase():"get";if(n==="get"){}i=ee(t,"action")}e.forEach(function(e){ht(t,function(e,t){if(v(e,Q.config.disableSelector)){m(e);return}he(n,i,e,t)},r,e,true)})}}function ut(e,t){if(e.type==="submit"||e.type==="click"){if(t.tagName==="FORM"){return true}if(h(t,'input[type="submit"], button')&&v(t,"form")!==null){return true}if(t.tagName==="A"&&t.href&&(t.getAttribute("href")==="#"||t.getAttribute("href").indexOf("#")!==0)){return true}}return false}function ft(e,t){return ae(e).boosted&&e.tagName==="A"&&t.type==="click"&&(t.ctrlKey||t.metaKey)}function ct(e,t,r){var n=e.eventFilter;if(n){try{return n.call(t,r)!==true}catch(e){fe(re().body,"htmx:eventFilter:error",{error:e,source:n.source});return true}}return false}function ht(a,o,e,s,l){var u=ae(a);var t;if(s.from){t=Z(a,s.from)}else{t=[a]}if(s.changed){t.forEach(function(e){var t=ae(e);t.lastValue=e.value})}oe(t,function(n){var i=function(e){if(!se(a)){n.removeEventListener(s.trigger,i);return}if(ft(a,e)){return}if(l||ut(e,a)){e.preventDefault()}if(ct(s,a,e)){return}var t=ae(e);t.triggerSpec=s;if(t.handledFor==null){t.handledFor=[]}if(t.handledFor.indexOf(a)<0){t.handledFor.push(a);if(s.consume){e.stopPropagation()}if(s.target&&e.target){if(!h(e.target,s.target)){return}}if(s.once){if(u.triggeredOnce){return}else{u.triggeredOnce=true}}if(s.changed){var r=ae(n);if(r.lastValue===n.value){return}r.lastValue=n.value}if(u.delayed){clearTimeout(u.delayed)}if(u.throttle){return}if(s.throttle>0){if(!u.throttle){o(a,e);u.throttle=setTimeout(function(){u.throttle=null},s.throttle)}}else if(s.delay>0){u.delayed=setTimeout(function(){o(a,e)},s.delay)}else{ce(a,"htmx:trigger");o(a,e)}}};if(e.listenerInfos==null){e.listenerInfos=[]}e.listenerInfos.push({trigger:s.trigger,listener:i,on:n});n.addEventListener(s.trigger,i)})}var vt=false;var dt=null;function gt(){if(!dt){dt=function(){vt=true};window.addEventListener("scroll",dt);setInterval(function(){if(vt){vt=false;oe(re().querySelectorAll("[hx-trigger='revealed'],[data-hx-trigger='revealed']"),function(e){pt(e)})}},200)}}function pt(t){if(!o(t,"data-hx-revealed")&&X(t)){t.setAttribute("data-hx-revealed","true");var e=ae(t);if(e.initHash){ce(t,"revealed")}else{t.addEventListener("htmx:afterProcessNode",function(e){ce(t,"revealed")},{once:true})}}}function mt(e,t,r){var n=D(r);for(var i=0;i<n.length;i++){var a=n[i].split(/:(.+)/);if(a[0]==="connect"){xt(e,a[1],0)}if(a[0]==="send"){bt(e)}}}function xt(s,r,n){if(!se(s)){return}if(r.indexOf("/")==0){var e=location.hostname+(location.port?":"+location.port:"");if(location.protocol=="https:"){r="wss://"+e+r}else if(location.protocol=="http:"){r="ws://"+e+r}}var t=Q.createWebSocket(r);t.onerror=function(e){fe(s,"htmx:wsError",{error:e,socket:t});yt(s)};t.onclose=function(e){if([1006,1012,1013].indexOf(e.code)>=0){var t=wt(n);setTimeout(function(){xt(s,r,n+1)},t)}};t.onopen=function(e){n=0};ae(s).webSocket=t;t.addEventListener("message",function(e){if(yt(s)){return}var t=e.data;R(s,function(e){t=e.transformResponse(t,null,s)});var r=T(s);var n=l(t);var i=M(n.children);for(var a=0;a<i.length;a++){var o=i[a];Ee(te(o,"hx-swap-oob")||"true",o,r)}nr(r.tasks)})}function yt(e){if(!se(e)){ae(e).webSocket.close();return true}}function bt(u){var f=c(u,function(e){return ae(e).webSocket!=null});if(f){u.addEventListener(it(u)[0].trigger,function(e){var t=ae(f).webSocket;var r=xr(u,f);var n=dr(u,"post");var i=n.errors;var a=n.values;var o=Hr(u);var s=le(a,o);var l=yr(s,u);l["HEADERS"]=r;if(i&&i.length>0){ce(u,"htmx:validation:halted",i);return}t.send(JSON.stringify(l));if(ut(e,u)){e.preventDefault()}})}else{fe(u,"htmx:noWebSocketSourceError")}}function wt(e){var t=Q.config.wsReconnectDelay;if(typeof t==="function"){return t(e)}if(t==="full-jitter"){var r=Math.min(e,6);var n=1e3*Math.pow(2,r);return n*Math.random()}b('htmx.config.wsReconnectDelay must either be a function or the string "full-jitter"')}function St(e,t,r){var n=D(r);for(var i=0;i<n.length;i++){var a=n[i].split(/:(.+)/);if(a[0]==="connect"){Et(e,a[1])}if(a[0]==="swap"){Ct(e,a[1])}}}function Et(t,e){var r=Q.createEventSource(e);r.onerror=function(e){fe(t,"htmx:sseError",{error:e,source:r});Tt(t)};ae(t).sseEventSource=r}function Ct(a,o){var s=c(a,Ot);if(s){var l=ae(s).sseEventSource;var u=function(e){if(Tt(s)){return}if(!se(a)){l.removeEventListener(o,u);return}var t=e.data;R(a,function(e){t=e.transformResponse(t,null,a)});var r=wr(a);var n=ye(a);var i=T(a);je(r.swapStyle,n,a,t,i);nr(i.tasks);ce(a,"htmx:sseMessage",e)};ae(a).sseListener=u;l.addEventListener(o,u)}else{fe(a,"htmx:noSSESourceError")}}function Rt(e,t,r){var n=c(e,Ot);if(n){var i=ae(n).sseEventSource;var a=function(){if(!Tt(n)){if(se(e)){t(e)}else{i.removeEventListener(r,a)}}};ae(e).sseListener=a;i.addEventListener(r,a)}else{fe(e,"htmx:noSSESourceError")}}function Tt(e){if(!se(e)){ae(e).sseEventSource.close();return true}}function Ot(e){return ae(e).sseEventSource!=null}function qt(e,t,r,n){var i=function(){if(!r.loaded){r.loaded=true;t(e)}};if(n>0){setTimeout(i,n)}else{i()}}function Ht(t,i,e){var a=false;oe(w,function(r){if(o(t,"hx-"+r)){var n=te(t,"hx-"+r);a=true;i.path=n;i.verb=r;e.forEach(function(e){Lt(t,e,i,function(e,t){if(v(e,Q.config.disableSelector)){m(e);return}he(r,n,e,t)})})}});return a}function Lt(n,e,t,r){if(e.sseEvent){Rt(n,r,e.sseEvent)}else if(e.trigger==="revealed"){gt();ht(n,r,t,e);pt(n)}else if(e.trigger==="intersect"){var i={};if(e.root){i.root=ue(n,e.root)}if(e.threshold){i.threshold=parseFloat(e.threshold)}var a=new IntersectionObserver(function(e){for(var t=0;t<e.length;t++){var r=e[t];if(r.isIntersecting){ce(n,"intersect");break}}},i);a.observe(n);ht(n,r,t,e)}else if(e.trigger==="load"){if(!ct(e,n,Wt("load",{elt:n}))){qt(n,r,t,e.delay)}}else if(e.pollInterval>0){t.polling=true;ot(n,r,e)}else{ht(n,r,t,e)}}function At(e){if(!e.htmxExecuted&&Q.config.allowScriptTags&&(e.type==="text/javascript"||e.type==="module"||e.type==="")){var t=re().createElement("script");oe(e.attributes,function(e){t.setAttribute(e.name,e.value)});t.textContent=e.textContent;t.async=false;if(Q.config.inlineScriptNonce){t.nonce=Q.config.inlineScriptNonce}var r=e.parentElement;try{r.insertBefore(t,e)}catch(e){b(e)}finally{if(e.parentElement){e.parentElement.removeChild(e)}}}}function Nt(e){if(h(e,"script")){At(e)}oe(f(e,"script"),function(e){At(e)})}function It(e){var t=e.attributes;if(!t){return false}for(var r=0;r<t.length;r++){var n=t[r].name;if(g(n,"hx-on:")||g(n,"data-hx-on:")||g(n,"hx-on-")||g(n,"data-hx-on-")){return true}}return false}function kt(e){var t=null;var r=[];if(It(e)){r.push(e)}if(document.evaluate){var n=document.evaluate('.//*[@*[ starts-with(name(), "hx-on:") or starts-with(name(), "data-hx-on:") or'+' starts-with(name(), "hx-on-") or starts-with(name(), "data-hx-on-") ]]',e);while(t=n.iterateNext())r.push(t)}else if(typeof e.getElementsByTagName==="function"){var i=e.getElementsByTagName("*");for(var a=0;a<i.length;a++){if(It(i[a])){r.push(i[a])}}}return r}function Pt(e){if(e.querySelectorAll){var t=", [hx-boost] a, [data-hx-boost] a, a[hx-boost], a[data-hx-boost]";var r=e.querySelectorAll(i+t+", form, [type='submit'], [hx-sse], [data-hx-sse], [hx-ws],"+" [data-hx-ws], [hx-ext], [data-hx-ext], [hx-trigger], [data-hx-trigger], [hx-on], [data-hx-on]");return r}else{return[]}}function Mt(e){var t=v(e.target,"button, input[type='submit']");var r=Dt(e);if(r){r.lastButtonClicked=t}}function Xt(e){var t=Dt(e);if(t){t.lastButtonClicked=null}}function Dt(e){var t=v(e.target,"button, input[type='submit']");if(!t){return}var r=p("#"+ee(t,"form"))||v(t,"form");if(!r){return}return ae(r)}function Ut(e){e.addEventListener("click",Mt);e.addEventListener("focusin",Mt);e.addEventListener("focusout",Xt)}function Bt(e){var t=Ye(e);var r=0;for(var n=0;n<t.length;n++){const i=t[n];if(i==="{"){r++}else if(i==="}"){r--}}return r}function Ft(t,e,r){var n=ae(t);if(!Array.isArray(n.onHandlers)){n.onHandlers=[]}var i;var a=function(e){return Tr(t,function(){if(!i){i=new Function("event",r)}i.call(t,e)})};t.addEventListener(e,a);n.onHandlers.push({event:e,listener:a})}function Vt(e){var t=te(e,"hx-on");if(t){var r={};var n=t.split("\n");var i=null;var a=0;while(n.length>0){var o=n.shift();var s=o.match(/^\s*([a-zA-Z:\-\.]+:)(.*)/);if(a===0&&s){o.split(":");i=s[1].slice(0,-1);r[i]=s[2]}else{r[i]+=o}a+=Bt(o)}for(var l in r){Ft(e,l,r[l])}}}function jt(e){Ae(e);for(var t=0;t<e.attributes.length;t++){var r=e.attributes[t].name;var n=e.attributes[t].value;if(g(r,"hx-on")||g(r,"data-hx-on")){var i=r.indexOf("-on")+3;var a=r.slice(i,i+1);if(a==="-"||a===":"){var o=r.slice(i+1);if(g(o,":")){o="htmx"+o}else if(g(o,"-")){o="htmx:"+o.slice(1)}else if(g(o,"htmx-")){o="htmx:"+o.slice(5)}Ft(e,o,n)}}}}function _t(t){if(v(t,Q.config.disableSelector)){m(t);return}var r=ae(t);if(r.initHash!==Le(t)){Ne(t);r.initHash=Le(t);Vt(t);ce(t,"htmx:beforeProcessNode");if(t.value){r.lastValue=t.value}var e=it(t);var n=Ht(t,r,e);if(!n){if(ne(t,"hx-boost")==="true"){lt(t,r,e)}else if(o(t,"hx-trigger")){e.forEach(function(e){Lt(t,e,r,function(){})})}}if(t.tagName==="FORM"||ee(t,"type")==="submit"&&o(t,"form")){Ut(t)}var i=te(t,"hx-sse");if(i){St(t,r,i)}var a=te(t,"hx-ws");if(a){mt(t,r,a)}ce(t,"htmx:afterProcessNode")}}function zt(e){e=p(e);if(v(e,Q.config.disableSelector)){m(e);return}_t(e);oe(Pt(e),function(e){_t(e)});oe(kt(e),jt)}function $t(e){return e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()}function Wt(e,t){var r;if(window.CustomEvent&&typeof window.CustomEvent==="function"){r=new CustomEvent(e,{bubbles:true,cancelable:true,detail:t})}else{r=re().createEvent("CustomEvent");r.initCustomEvent(e,true,true,t)}return r}function fe(e,t,r){ce(e,t,le({error:t},r))}function Gt(e){return e==="htmx:afterProcessNode"}function R(e,t){oe(Fr(e),function(e){try{t(e)}catch(e){b(e)}})}function b(e){if(console.error){console.error(e)}else if(console.log){console.log("ERROR: ",e)}}function ce(e,t,r){e=p(e);if(r==null){r={}}r["elt"]=e;var n=Wt(t,r);if(Q.logger&&!Gt(t)){Q.logger(e,t,r)}if(r.error){b(r.error);ce(e,"htmx:error",{errorInfo:r})}var i=e.dispatchEvent(n);var a=$t(t);if(i&&a!==t){var o=Wt(a,n.detail);i=i&&e.dispatchEvent(o)}R(e,function(e){i=i&&(e.onEvent(t,n)!==false&&!n.defaultPrevented)});return i}var Jt=location.pathname+location.search;function Zt(){var e=re().querySelector("[hx-history-elt],[data-hx-history-elt]");return e||re().body}function Kt(e,t,r,n){if(!U()){return}if(Q.config.historyCacheSize<=0){localStorage.removeItem("htmx-history-cache");return}e=B(e);var i=E(localStorage.getItem("htmx-history-cache"))||[];for(var a=0;a<i.length;a++){if(i[a].url===e){i.splice(a,1);break}}var o={url:e,content:t,title:r,scroll:n};ce(re().body,"htmx:historyItemCreated",{item:o,cache:i});i.push(o);while(i.length>Q.config.historyCacheSize){i.shift()}while(i.length>0){try{localStorage.setItem("htmx-history-cache",JSON.stringify(i));break}catch(e){fe(re().body,"htmx:historyCacheError",{cause:e,cache:i});i.shift()}}}function Yt(e){if(!U()){return null}e=B(e);var t=E(localStorage.getItem("htmx-history-cache"))||[];for(var r=0;r<t.length;r++){if(t[r].url===e){return t[r]}}return null}function Qt(e){var t=Q.config.requestClass;var r=e.cloneNode(true);oe(f(r,"."+t),function(e){n(e,t)});return r.innerHTML}function er(){var e=Zt();var t=Jt||location.pathname+location.search;var r;try{r=re().querySelector('[hx-history="false" i],[data-hx-history="false" i]')}catch(e){r=re().querySelector('[hx-history="false"],[data-hx-history="false"]')}if(!r){ce(re().body,"htmx:beforeHistorySave",{path:t,historyElt:e});Kt(t,Qt(e),re().title,window.scrollY)}if(Q.config.historyEnabled)history.replaceState({htmx:true},re().title,window.location.href)}function tr(e){if(Q.config.getCacheBusterParam){e=e.replace(/org\.htmx\.cache-buster=[^&]*&?/,"");if(G(e,"&")||G(e,"?")){e=e.slice(0,-1)}}if(Q.config.historyEnabled){history.pushState({htmx:true},"",e)}Jt=e}function rr(e){if(Q.config.historyEnabled)history.replaceState({htmx:true},"",e);Jt=e}function nr(e){oe(e,function(e){e.call()})}function ir(a){var e=new XMLHttpRequest;var o={path:a,xhr:e};ce(re().body,"htmx:historyCacheMiss",o);e.open("GET",a,true);e.setRequestHeader("HX-Request","true");e.setRequestHeader("HX-History-Restore-Request","true");e.setRequestHeader("HX-Current-URL",re().location.href);e.onload=function(){if(this.status>=200&&this.status<400){ce(re().body,"htmx:historyCacheMissLoad",o);var e=l(this.response);e=e.querySelector("[hx-history-elt],[data-hx-history-elt]")||e;var t=Zt();var r=T(t);var n=Ve(this.response);if(n){var i=C("title");if(i){i.innerHTML=n}else{window.document.title=n}}Ue(t,e,r);nr(r.tasks);Jt=a;ce(re().body,"htmx:historyRestore",{path:a,cacheMiss:true,serverResponse:this.response})}else{fe(re().body,"htmx:historyCacheMissLoadError",o)}};e.send()}function ar(e){er();e=e||location.pathname+location.search;var t=Yt(e);if(t){var r=l(t.content);var n=Zt();var i=T(n);Ue(n,r,i);nr(i.tasks);document.title=t.title;setTimeout(function(){window.scrollTo(0,t.scroll)},0);Jt=e;ce(re().body,"htmx:historyRestore",{path:e,item:t})}else{if(Q.config.refreshOnHistoryMiss){window.location.reload(true)}else{ir(e)}}}function or(e){var t=me(e,"hx-indicator");if(t==null){t=[e]}oe(t,function(e){var t=ae(e);t.requestCount=(t.requestCount||0)+1;e.classList["add"].call(e.classList,Q.config.requestClass)});return t}function sr(e){var t=me(e,"hx-disabled-elt");if(t==null){t=[]}oe(t,function(e){var t=ae(e);t.requestCount=(t.requestCount||0)+1;e.setAttribute("disabled","")});return t}function lr(e,t){oe(e,function(e){var t=ae(e);t.requestCount=(t.requestCount||0)-1;if(t.requestCount===0){e.classList["remove"].call(e.classList,Q.config.requestClass)}});oe(t,function(e){var t=ae(e);t.requestCount=(t.requestCount||0)-1;if(t.requestCount===0){e.removeAttribute("disabled")}})}function ur(e,t){for(var r=0;r<e.length;r++){var n=e[r];if(n.isSameNode(t)){return true}}return false}function fr(e){if(e.name===""||e.name==null||e.disabled||v(e,"fieldset[disabled]")){return false}if(e.type==="button"||e.type==="submit"||e.tagName==="image"||e.tagName==="reset"||e.tagName==="file"){return false}if(e.type==="checkbox"||e.type==="radio"){return e.checked}return true}function cr(e,t,r){if(e!=null&&t!=null){var n=r[e];if(n===undefined){r[e]=t}else if(Array.isArray(n)){if(Array.isArray(t)){r[e]=n.concat(t)}else{n.push(t)}}else{if(Array.isArray(t)){r[e]=[n].concat(t)}else{r[e]=[n,t]}}}}function hr(t,r,n,e,i){if(e==null||ur(t,e)){return}else{t.push(e)}if(fr(e)){var a=ee(e,"name");var o=e.value;if(e.multiple&&e.tagName==="SELECT"){o=M(e.querySelectorAll("option:checked")).map(function(e){return e.value})}if(e.files){o=M(e.files)}cr(a,o,r);if(i){vr(e,n)}}if(h(e,"form")){var s=e.elements;oe(s,function(e){hr(t,r,n,e,i)})}}function vr(e,t){if(e.willValidate){ce(e,"htmx:validation:validate");if(!e.checkValidity()){t.push({elt:e,message:e.validationMessage,validity:e.validity});ce(e,"htmx:validation:failed",{message:e.validationMessage,validity:e.validity})}}}function dr(e,t){var r=[];var n={};var i={};var a=[];var o=ae(e);if(o.lastButtonClicked&&!se(o.lastButtonClicked)){o.lastButtonClicked=null}var s=h(e,"form")&&e.noValidate!==true||te(e,"hx-validate")==="true";if(o.lastButtonClicked){s=s&&o.lastButtonClicked.formNoValidate!==true}if(t!=="get"){hr(r,i,a,v(e,"form"),s)}hr(r,n,a,e,s);if(o.lastButtonClicked||e.tagName==="BUTTON"||e.tagName==="INPUT"&&ee(e,"type")==="submit"){var l=o.lastButtonClicked||e;var u=ee(l,"name");cr(u,l.value,i)}var f=me(e,"hx-include");oe(f,function(e){hr(r,n,a,e,s);if(!h(e,"form")){oe(e.querySelectorAll(rt),function(e){hr(r,n,a,e,s)})}});n=le(n,i);return{errors:a,values:n}}function gr(e,t,r){if(e!==""){e+="&"}if(String(r)==="[object Object]"){r=JSON.stringify(r)}var n=encodeURIComponent(r);e+=encodeURIComponent(t)+"="+n;return e}function pr(e){var t="";for(var r in e){if(e.hasOwnProperty(r)){var n=e[r];if(Array.isArray(n)){oe(n,function(e){t=gr(t,r,e)})}else{t=gr(t,r,n)}}}return t}function mr(e){var t=new FormData;for(var r in e){if(e.hasOwnProperty(r)){var n=e[r];if(Array.isArray(n)){oe(n,function(e){t.append(r,e)})}else{t.append(r,n)}}}return t}function xr(e,t,r){var n={"HX-Request":"true","HX-Trigger":ee(e,"id"),"HX-Trigger-Name":ee(e,"name"),"HX-Target":te(t,"id"),"HX-Current-URL":re().location.href};Rr(e,"hx-headers",false,n);if(r!==undefined){n["HX-Prompt"]=r}if(ae(e).boosted){n["HX-Boosted"]="true"}return n}function yr(t,e){var r=ne(e,"hx-params");if(r){if(r==="none"){return{}}else if(r==="*"){return t}else if(r.indexOf("not ")===0){oe(r.substr(4).split(","),function(e){e=e.trim();delete t[e]});return t}else{var n={};oe(r.split(","),function(e){e=e.trim();n[e]=t[e]});return n}}else{return t}}function br(e){return ee(e,"href")&&ee(e,"href").indexOf("#")>=0}function wr(e,t){var r=t?t:ne(e,"hx-swap");var n={swapStyle:ae(e).boosted?"innerHTML":Q.config.defaultSwapStyle,swapDelay:Q.config.defaultSwapDelay,settleDelay:Q.config.defaultSettleDelay};if(Q.config.scrollIntoViewOnBoost&&ae(e).boosted&&!br(e)){n["show"]="top"}if(r){var i=D(r);if(i.length>0){for(var a=0;a<i.length;a++){var o=i[a];if(o.indexOf("swap:")===0){n["swapDelay"]=d(o.substr(5))}else if(o.indexOf("settle:")===0){n["settleDelay"]=d(o.substr(7))}else if(o.indexOf("transition:")===0){n["transition"]=o.substr(11)==="true"}else if(o.indexOf("ignoreTitle:")===0){n["ignoreTitle"]=o.substr(12)==="true"}else if(o.indexOf("scroll:")===0){var s=o.substr(7);var l=s.split(":");var u=l.pop();var f=l.length>0?l.join(":"):null;n["scroll"]=u;n["scrollTarget"]=f}else if(o.indexOf("show:")===0){var c=o.substr(5);var l=c.split(":");var h=l.pop();var f=l.length>0?l.join(":"):null;n["show"]=h;n["showTarget"]=f}else if(o.indexOf("focus-scroll:")===0){var v=o.substr("focus-scroll:".length);n["focusScroll"]=v=="true"}else if(a==0){n["swapStyle"]=o}else{b("Unknown modifier in hx-swap: "+o)}}}}return n}function Sr(e){return ne(e,"hx-encoding")==="multipart/form-data"||h(e,"form")&&ee(e,"enctype")==="multipart/form-data"}function Er(t,r,n){var i=null;R(r,function(e){if(i==null){i=e.encodeParameters(t,n,r)}});if(i!=null){return i}else{if(Sr(r)){return mr(n)}else{return pr(n)}}}function T(e){return{tasks:[],elts:[e]}}function Cr(e,t){var r=e[0];var n=e[e.length-1];if(t.scroll){var i=null;if(t.scrollTarget){i=ue(r,t.scrollTarget)}if(t.scroll==="top"&&(r||i)){i=i||r;i.scrollTop=0}if(t.scroll==="bottom"&&(n||i)){i=i||n;i.scrollTop=i.scrollHeight}}if(t.show){var i=null;if(t.showTarget){var a=t.showTarget;if(t.showTarget==="window"){a="body"}i=ue(r,a)}if(t.show==="top"&&(r||i)){i=i||r;i.scrollIntoView({block:"start",behavior:Q.config.scrollBehavior})}if(t.show==="bottom"&&(n||i)){i=i||n;i.scrollIntoView({block:"end",behavior:Q.config.scrollBehavior})}}}function Rr(e,t,r,n){if(n==null){n={}}if(e==null){return n}var i=te(e,t);if(i){var a=i.trim();var o=r;if(a==="unset"){return null}if(a.indexOf("javascript:")===0){a=a.substr(11);o=true}else if(a.indexOf("js:")===0){a=a.substr(3);o=true}if(a.indexOf("{")!==0){a="{"+a+"}"}var s;if(o){s=Tr(e,function(){return Function("return ("+a+")")()},{})}else{s=E(a)}for(var l in s){if(s.hasOwnProperty(l)){if(n[l]==null){n[l]=s[l]}}}}return Rr(u(e),t,r,n)}function Tr(e,t,r){if(Q.config.allowEval){return t()}else{fe(e,"htmx:evalDisallowedError");return r}}function Or(e,t){return Rr(e,"hx-vars",true,t)}function qr(e,t){return Rr(e,"hx-vals",false,t)}function Hr(e){return le(Or(e),qr(e))}function Lr(t,r,n){if(n!==null){try{t.setRequestHeader(r,n)}catch(e){t.setRequestHeader(r,encodeURIComponent(n));t.setRequestHeader(r+"-URI-AutoEncoded","true")}}}function Ar(t){if(t.responseURL&&typeof URL!=="undefined"){try{var e=new URL(t.responseURL);return e.pathname+e.search}catch(e){fe(re().body,"htmx:badResponseUrl",{url:t.responseURL})}}}function O(e,t){return t.test(e.getAllResponseHeaders())}function Nr(e,t,r){e=e.toLowerCase();if(r){if(r instanceof Element||I(r,"String")){return he(e,t,null,null,{targetOverride:p(r),returnPromise:true})}else{return he(e,t,p(r.source),r.event,{handler:r.handler,headers:r.headers,values:r.values,targetOverride:p(r.target),swapOverride:r.swap,select:r.select,returnPromise:true})}}else{return he(e,t,null,null,{returnPromise:true})}}function Ir(e){var t=[];while(e){t.push(e);e=e.parentElement}return t}function kr(e,t,r){var n;var i;if(typeof URL==="function"){i=new URL(t,document.location.href);var a=document.location.origin;n=a===i.origin}else{i=t;n=g(t,document.location.origin)}if(Q.config.selfRequestsOnly){if(!n){return false}}return ce(e,"htmx:validateUrl",le({url:i,sameHost:n},r))}function he(t,r,n,i,a,e){var o=null;var s=null;a=a!=null?a:{};if(a.returnPromise&&typeof Promise!=="undefined"){var l=new Promise(function(e,t){o=e;s=t})}if(n==null){n=re().body}var M=a.handler||Mr;var X=a.select||null;if(!se(n)){ie(o);return l}var u=a.targetOverride||ye(n);if(u==null||u==pe){fe(n,"htmx:targetError",{target:te(n,"hx-target")});ie(s);return l}var f=ae(n);var c=f.lastButtonClicked;if(c){var h=ee(c,"formaction");if(h!=null){r=h}var v=ee(c,"formmethod");if(v!=null){if(v.toLowerCase()!=="dialog"){t=v}}}var d=ne(n,"hx-confirm");if(e===undefined){var D=function(e){return he(t,r,n,i,a,!!e)};var U={target:u,elt:n,path:r,verb:t,triggeringEvent:i,etc:a,issueRequest:D,question:d};if(ce(n,"htmx:confirm",U)===false){ie(o);return l}}var g=n;var p=ne(n,"hx-sync");var m=null;var x=false;if(p){var B=p.split(":");var F=B[0].trim();if(F==="this"){g=xe(n,"hx-sync")}else{g=ue(n,F)}p=(B[1]||"drop").trim();f=ae(g);if(p==="drop"&&f.xhr&&f.abortable!==true){ie(o);return l}else if(p==="abort"){if(f.xhr){ie(o);return l}else{x=true}}else if(p==="replace"){ce(g,"htmx:abort")}else if(p.indexOf("queue")===0){var V=p.split(" ");m=(V[1]||"last").trim()}}if(f.xhr){if(f.abortable){ce(g,"htmx:abort")}else{if(m==null){if(i){var y=ae(i);if(y&&y.triggerSpec&&y.triggerSpec.queue){m=y.triggerSpec.queue}}if(m==null){m="last"}}if(f.queuedRequests==null){f.queuedRequests=[]}if(m==="first"&&f.queuedRequests.length===0){f.queuedRequests.push(function(){he(t,r,n,i,a)})}else if(m==="all"){f.queuedRequests.push(function(){he(t,r,n,i,a)})}else if(m==="last"){f.queuedRequests=[];f.queuedRequests.push(function(){he(t,r,n,i,a)})}ie(o);return l}}var b=new XMLHttpRequest;f.xhr=b;f.abortable=x;var w=function(){f.xhr=null;f.abortable=false;if(f.queuedRequests!=null&&f.queuedRequests.length>0){var e=f.queuedRequests.shift();e()}};var j=ne(n,"hx-prompt");if(j){var S=prompt(j);if(S===null||!ce(n,"htmx:prompt",{prompt:S,target:u})){ie(o);w();return l}}if(d&&!e){if(!confirm(d)){ie(o);w();return l}}var E=xr(n,u,S);if(t!=="get"&&!Sr(n)){E["Content-Type"]="application/x-www-form-urlencoded"}if(a.headers){E=le(E,a.headers)}var _=dr(n,t);var C=_.errors;var R=_.values;if(a.values){R=le(R,a.values)}var z=Hr(n);var $=le(R,z);var T=yr($,n);if(Q.config.getCacheBusterParam&&t==="get"){T["org.htmx.cache-buster"]=ee(u,"id")||"true"}if(r==null||r===""){r=re().location.href}var O=Rr(n,"hx-request");var W=ae(n).boosted;var q=Q.config.methodsThatUseUrlParams.indexOf(t)>=0;var H={boosted:W,useUrlParams:q,parameters:T,unfilteredParameters:$,headers:E,target:u,verb:t,errors:C,withCredentials:a.credentials||O.credentials||Q.config.withCredentials,timeout:a.timeout||O.timeout||Q.config.timeout,path:r,triggeringEvent:i};if(!ce(n,"htmx:configRequest",H)){ie(o);w();return l}r=H.path;t=H.verb;E=H.headers;T=H.parameters;C=H.errors;q=H.useUrlParams;if(C&&C.length>0){ce(n,"htmx:validation:halted",H);ie(o);w();return l}var G=r.split("#");var J=G[0];var L=G[1];var A=r;if(q){A=J;var Z=Object.keys(T).length!==0;if(Z){if(A.indexOf("?")<0){A+="?"}else{A+="&"}A+=pr(T);if(L){A+="#"+L}}}if(!kr(n,A,H)){fe(n,"htmx:invalidPath",H);ie(s);return l}b.open(t.toUpperCase(),A,true);b.overrideMimeType("text/html");b.withCredentials=H.withCredentials;b.timeout=H.timeout;if(O.noHeaders){}else{for(var N in E){if(E.hasOwnProperty(N)){var K=E[N];Lr(b,N,K)}}}var I={xhr:b,target:u,requestConfig:H,etc:a,boosted:W,select:X,pathInfo:{requestPath:r,finalRequestPath:A,anchor:L}};b.onload=function(){try{var e=Ir(n);I.pathInfo.responsePath=Ar(b);M(n,I);lr(k,P);ce(n,"htmx:afterRequest",I);ce(n,"htmx:afterOnLoad",I);if(!se(n)){var t=null;while(e.length>0&&t==null){var r=e.shift();if(se(r)){t=r}}if(t){ce(t,"htmx:afterRequest",I);ce(t,"htmx:afterOnLoad",I)}}ie(o);w()}catch(e){fe(n,"htmx:onLoadError",le({error:e},I));throw e}};b.onerror=function(){lr(k,P);fe(n,"htmx:afterRequest",I);fe(n,"htmx:sendError",I);ie(s);w()};b.onabort=function(){lr(k,P);fe(n,"htmx:afterRequest",I);fe(n,"htmx:sendAbort",I);ie(s);w()};b.ontimeout=function(){lr(k,P);fe(n,"htmx:afterRequest",I);fe(n,"htmx:timeout",I);ie(s);w()};if(!ce(n,"htmx:beforeRequest",I)){ie(o);w();return l}var k=or(n);var P=sr(n);oe(["loadstart","loadend","progress","abort"],function(t){oe([b,b.upload],function(e){e.addEventListener(t,function(e){ce(n,"htmx:xhr:"+t,{lengthComputable:e.lengthComputable,loaded:e.loaded,total:e.total})})})});ce(n,"htmx:beforeSend",I);var Y=q?null:Er(b,n,T);b.send(Y);return l}function Pr(e,t){var r=t.xhr;var n=null;var i=null;if(O(r,/HX-Push:/i)){n=r.getResponseHeader("HX-Push");i="push"}else if(O(r,/HX-Push-Url:/i)){n=r.getResponseHeader("HX-Push-Url");i="push"}else if(O(r,/HX-Replace-Url:/i)){n=r.getResponseHeader("HX-Replace-Url");i="replace"}if(n){if(n==="false"){return{}}else{return{type:i,path:n}}}var a=t.pathInfo.finalRequestPath;var o=t.pathInfo.responsePath;var s=ne(e,"hx-push-url");var l=ne(e,"hx-replace-url");var u=ae(e).boosted;var f=null;var c=null;if(s){f="push";c=s}else if(l){f="replace";c=l}else if(u){f="push";c=o||a}if(c){if(c==="false"){return{}}if(c==="true"){c=o||a}if(t.pathInfo.anchor&&c.indexOf("#")===-1){c=c+"#"+t.pathInfo.anchor}return{type:f,path:c}}else{return{}}}function Mr(l,u){var f=u.xhr;var c=u.target;var e=u.etc;var t=u.requestConfig;var h=u.select;if(!ce(l,"htmx:beforeOnLoad",u))return;if(O(f,/HX-Trigger:/i)){_e(f,"HX-Trigger",l)}if(O(f,/HX-Location:/i)){er();var r=f.getResponseHeader("HX-Location");var v;if(r.indexOf("{")===0){v=E(r);r=v["path"];delete v["path"]}Nr("GET",r,v).then(function(){tr(r)});return}var n=O(f,/HX-Refresh:/i)&&"true"===f.getResponseHeader("HX-Refresh");if(O(f,/HX-Redirect:/i)){location.href=f.getResponseHeader("HX-Redirect");n&&location.reload();return}if(n){location.reload();return}if(O(f,/HX-Retarget:/i)){if(f.getResponseHeader("HX-Retarget")==="this"){u.target=l}else{u.target=ue(l,f.getResponseHeader("HX-Retarget"))}}var d=Pr(l,u);var i=f.status>=200&&f.status<400&&f.status!==204;var g=f.response;var a=f.status>=400;var p=Q.config.ignoreTitle;var o=le({shouldSwap:i,serverResponse:g,isError:a,ignoreTitle:p},u);if(!ce(c,"htmx:beforeSwap",o))return;c=o.target;g=o.serverResponse;a=o.isError;p=o.ignoreTitle;u.target=c;u.failed=a;u.successful=!a;if(o.shouldSwap){if(f.status===286){at(l)}R(l,function(e){g=e.transformResponse(g,f,l)});if(d.type){er()}var s=e.swapOverride;if(O(f,/HX-Reswap:/i)){s=f.getResponseHeader("HX-Reswap")}var v=wr(l,s);if(v.hasOwnProperty("ignoreTitle")){p=v.ignoreTitle}c.classList.add(Q.config.swappingClass);var m=null;var x=null;var y=function(){try{var e=document.activeElement;var t={};try{t={elt:e,start:e?e.selectionStart:null,end:e?e.selectionEnd:null}}catch(e){}var r;if(h){r=h}if(O(f,/HX-Reselect:/i)){r=f.getResponseHeader("HX-Reselect")}if(d.type){ce(re().body,"htmx:beforeHistoryUpdate",le({history:d},u));if(d.type==="push"){tr(d.path);ce(re().body,"htmx:pushedIntoHistory",{path:d.path})}else{rr(d.path);ce(re().body,"htmx:replacedInHistory",{path:d.path})}}var n=T(c);je(v.swapStyle,c,l,g,n,r);if(t.elt&&!se(t.elt)&&ee(t.elt,"id")){var i=document.getElementById(ee(t.elt,"id"));var a={preventScroll:v.focusScroll!==undefined?!v.focusScroll:!Q.config.defaultFocusScroll};if(i){if(t.start&&i.setSelectionRange){try{i.setSelectionRange(t.start,t.end)}catch(e){}}i.focus(a)}}c.classList.remove(Q.config.swappingClass);oe(n.elts,function(e){if(e.classList){e.classList.add(Q.config.settlingClass)}ce(e,"htmx:afterSwap",u)});if(O(f,/HX-Trigger-After-Swap:/i)){var o=l;if(!se(l)){o=re().body}_e(f,"HX-Trigger-After-Swap",o)}var s=function(){oe(n.tasks,function(e){e.call()});oe(n.elts,function(e){if(e.classList){e.classList.remove(Q.config.settlingClass)}ce(e,"htmx:afterSettle",u)});if(u.pathInfo.anchor){var e=re().getElementById(u.pathInfo.anchor);if(e){e.scrollIntoView({block:"start",behavior:"auto"})}}if(n.title&&!p){var t=C("title");if(t){t.innerHTML=n.title}else{window.document.title=n.title}}Cr(n.elts,v);if(O(f,/HX-Trigger-After-Settle:/i)){var r=l;if(!se(l)){r=re().body}_e(f,"HX-Trigger-After-Settle",r)}ie(m)};if(v.settleDelay>0){setTimeout(s,v.settleDelay)}else{s()}}catch(e){fe(l,"htmx:swapError",u);ie(x);throw e}};var b=Q.config.globalViewTransitions;if(v.hasOwnProperty("transition")){b=v.transition}if(b&&ce(l,"htmx:beforeTransition",u)&&typeof Promise!=="undefined"&&document.startViewTransition){var w=new Promise(function(e,t){m=e;x=t});var S=y;y=function(){document.startViewTransition(function(){S();return w})}}if(v.swapDelay>0){setTimeout(y,v.swapDelay)}else{y()}}if(a){fe(l,"htmx:responseError",le({error:"Response Status Error Code "+f.status+" from "+u.pathInfo.requestPath},u))}}var Xr={};function Dr(){return{init:function(e){return null},onEvent:function(e,t){return true},transformResponse:function(e,t,r){return e},isInlineSwap:function(e){return false},handleSwap:function(e,t,r,n){return false},encodeParameters:function(e,t,r){return null}}}function Ur(e,t){if(t.init){t.init(r)}Xr[e]=le(Dr(),t)}function Br(e){delete Xr[e]}function Fr(e,r,n){if(e==undefined){return r}if(r==undefined){r=[]}if(n==undefined){n=[]}var t=te(e,"hx-ext");if(t){oe(t.split(","),function(e){e=e.replace(/ /g,"");if(e.slice(0,7)=="ignore:"){n.push(e.slice(7));return}if(n.indexOf(e)<0){var t=Xr[e];if(t&&r.indexOf(t)<0){r.push(t)}}})}return Fr(u(e),r,n)}var Vr=false;re().addEventListener("DOMContentLoaded",function(){Vr=true});function jr(e){if(Vr||re().readyState==="complete"){e()}else{re().addEventListener("DOMContentLoaded",e)}}function _r(){if(Q.config.includeIndicatorStyles!==false){re().head.insertAdjacentHTML("beforeend","<style>                      ."+Q.config.indicatorClass+"{opacity:0}                      ."+Q.config.requestClass+" ."+Q.config.indicatorClass+"{opacity:1; transition: opacity 200ms ease-in;}                      ."+Q.config.requestClass+"."+Q.config.indicatorClass+"{opacity:1; transition: opacity 200ms ease-in;}                    </style>")}}function zr(){var e=re().querySelector('meta[name="htmx-config"]');if(e){return E(e.content)}else{return null}}function $r(){var e=zr();if(e){Q.config=le(Q.config,e)}}jr(function(){$r();_r();var e=re().body;zt(e);var t=re().querySelectorAll("[hx-trigger='restored'],[data-hx-trigger='restored']");e.addEventListener("htmx:abort",function(e){var t=e.target;var r=ae(t);if(r&&r.xhr){r.xhr.abort()}});const r=window.onpopstate?window.onpopstate.bind(window):null;window.onpopstate=function(e){if(e.state&&e.state.htmx){ar();oe(t,function(e){ce(e,"htmx:restored",{document:re(),triggerEvent:ce})})}else{if(r){r(e)}}};setTimeout(function(){ce(e,"htmx:load",{});e=null},0)});return Q}()});)RAW";
constexpr char const htmx_rt_js_content[] = R"RAW((function () {  var api;  var attrPrefix = "hx-target-";  function startsWith(str, prefix) {    return str.substring(0, prefix.length) === prefix;  }  function getRespCodeTarget(elt, respCodeNumber) {    if (!elt || !respCodeNumber) return null;    var respCode = respCodeNumber.toString();    var attrPossibilities = [      respCode,      respCode.substr(0, 2) + "*",      respCode.substr(0, 2) + "x",      respCode.substr(0, 1) + "*",      respCode.substr(0, 1) + "x",      respCode.substr(0, 1) + "**",      respCode.substr(0, 1) + "xx",      "*",      "x",      "***",      "xxx",    ];    if (startsWith(respCode, "4") || startsWith(respCode, "5")) {      attrPossibilities.push("error");    }    for (var i = 0; i < attrPossibilities.length; i++) {      var attr = attrPrefix + attrPossibilities[i];      var attrValue = api.getClosestAttributeValue(elt, attr);      if (attrValue) {        if (attrValue === "this") {          return api.findThisElement(elt, attr);        } else {          return api.querySelectorExt(elt, attrValue);        }      }    }    return null;  }  function handleErrorFlag(evt) {    if (evt.detail.isError) {      if (htmx.config.responseTargetUnsetsError) {        evt.detail.isError = false;      }    } else if (htmx.config.responseTargetSetsError) {      evt.detail.isError = true;    }  }  htmx.defineExtension("response-targets", {    init: function (apiRef) {      api = apiRef;      if (htmx.config.responseTargetUnsetsError === undefined) {        htmx.config.responseTargetUnsetsError = true;      }      if (htmx.config.responseTargetSetsError === undefined) {        htmx.config.responseTargetSetsError = false;      }      if (htmx.config.responseTargetPrefersExisting === undefined) {        htmx.config.responseTargetPrefersExisting = false;      }      if (htmx.config.responseTargetPrefersRetargetHeader === undefined) {        htmx.config.responseTargetPrefersRetargetHeader = true;      }    },    onEvent: function (name, evt) {      if (        name === "htmx:beforeSwap" &&        evt.detail.xhr &&        evt.detail.xhr.status !== 200      ) {        if (evt.detail.target) {          if (htmx.config.responseTargetPrefersExisting) {            evt.detail.shouldSwap = true;            handleErrorFlag(evt);            return true;          }          if (            htmx.config.responseTargetPrefersRetargetHeader &&            evt.detail.xhr.getAllResponseHeaders().match(/HX-Retarget:/i)          ) {            evt.detail.shouldSwap = true;            handleErrorFlag(evt);            return true;          }        }        if (!evt.detail.requestConfig) {          return true;        }        var target = getRespCodeTarget(          evt.detail.requestConfig.elt,          evt.detail.xhr.status,        );        if (target) {          handleErrorFlag(evt);          evt.detail.shouldSwap = true;          evt.detail.target = target;        }        return true;      }    },  });})();)RAW";
constexpr char const htmx_js_content[] = R"RAW(var htmx = (function () {  "use strict";  const htmx = {    onLoad: null,    process: null,    on: null,    off: null,    trigger: null,    ajax: null,    find: null,    findAll: null,    closest: null,    values: function (elt, type) {      const inputValues = getInputValues(elt, type || "post");      return inputValues.values;    },    remove: null,    addClass: null,    removeClass: null,    toggleClass: null,    takeClass: null,    swap: null,    defineExtension: null,    removeExtension: null,    logAll: null,    logNone: null,    logger: null,    config: {      historyEnabled: true,      historyCacheSize: 10,      refreshOnHistoryMiss: false,      defaultSwapStyle: "innerHTML",      defaultSwapDelay: 0,      defaultSettleDelay: 20,      includeIndicatorStyles: true,      indicatorClass: "htmx-indicator",      requestClass: "htmx-request",      addedClass: "htmx-added",      settlingClass: "htmx-settling",      swappingClass: "htmx-swapping",      allowEval: true,      allowScriptTags: true,      inlineScriptNonce: "",      inlineStyleNonce: "",      attributesToSettle: ["class", "style", "width", "height"],      withCredentials: false,      timeout: 0,      wsReconnectDelay: "full-jitter",      wsBinaryType: "blob",      disableSelector: "[hx-disable], [data-hx-disable]",      scrollBehavior: "instant",      defaultFocusScroll: false,      getCacheBusterParam: false,      globalViewTransitions: false,      methodsThatUseUrlParams: ["get", "delete"],      selfRequestsOnly: true,      ignoreTitle: false,      scrollIntoViewOnBoost: true,      triggerSpecsCache: null,      disableInheritance: false,      responseHandling: [        { code: "204", swap: false },        { code: "[23]..", swap: true },        { code: "[45]..", swap: false, error: true },      ],      allowNestedOobSwaps: true,    },    parseInterval: null,    _: null,    version: "2.0.3",  };  htmx.onLoad = onLoadHelper;  htmx.process = processNode;  htmx.on = addEventListenerImpl;  htmx.off = removeEventListenerImpl;  htmx.trigger = triggerEvent;  htmx.ajax = ajaxHelper;  htmx.find = find;  htmx.findAll = findAll;  htmx.closest = closest;  htmx.remove = removeElement;  htmx.addClass = addClassToElement;  htmx.removeClass = removeClassFromElement;  htmx.toggleClass = toggleClassOnElement;  htmx.takeClass = takeClassForElement;  htmx.swap = swap;  htmx.defineExtension = defineExtension;  htmx.removeExtension = removeExtension;  htmx.logAll = logAll;  htmx.logNone = logNone;  htmx.parseInterval = parseInterval;  htmx._ = internalEval;  const internalAPI = {    addTriggerHandler,    bodyContains,    canAccessLocalStorage,    findThisElement,    filterValues,    swap,    hasAttribute,    getAttributeValue,    getClosestAttributeValue,    getClosestMatch,    getExpressionVars,    getHeaders,    getInputValues,    getInternalData,    getSwapSpecification,    getTriggerSpecs,    getTarget,    makeFragment,    mergeObjects,    makeSettleInfo,    oobSwap,    querySelectorExt,    settleImmediately,    shouldCancel,    triggerEvent,    triggerErrorEvent,    withExtensions,  };  const VERBS = ["get", "post", "put", "delete", "patch"];  const VERB_SELECTOR = VERBS.map(function (verb) {    return "[hx-" + verb + "], [data-hx-" + verb + "]";  }).join(", ");  function parseInterval(str) {    if (str == undefined) {      return undefined;    }    let interval = NaN;    if (str.slice(-2) == "ms") {      interval = parseFloat(str.slice(0, -2));    } else if (str.slice(-1) == "s") {      interval = parseFloat(str.slice(0, -1)) * 1000;    } else if (str.slice(-1) == "m") {      interval = parseFloat(str.slice(0, -1)) * 1000 * 60;    } else {      interval = parseFloat(str);    }    return isNaN(interval) ? undefined : interval;  }  function getRawAttribute(elt, name) {    return elt instanceof Element && elt.getAttribute(name);  }  function hasAttribute(elt, qualifiedName) {    return (      !!elt.hasAttribute &&      (elt.hasAttribute(qualifiedName) ||        elt.hasAttribute("data-" + qualifiedName))    );  }  function getAttributeValue(elt, qualifiedName) {    return (      getRawAttribute(elt, qualifiedName) ||      getRawAttribute(elt, "data-" + qualifiedName)    );  }  function parentElt(elt) {    const parent = elt.parentElement;    if (!parent && elt.parentNode instanceof ShadowRoot) return elt.parentNode;    return parent;  }  function getDocument() {    return document;  }  function getRootNode(elt, global) {    return elt.getRootNode      ? elt.getRootNode({ composed: global })      : getDocument();  }  function getClosestMatch(elt, condition) {    while (elt && !condition(elt)) {      elt = parentElt(elt);    }    return elt || null;  }  function getAttributeValueWithDisinheritance(    initialElement,    ancestor,    attributeName,  ) {    const attributeValue = getAttributeValue(ancestor, attributeName);    const disinherit = getAttributeValue(ancestor, "hx-disinherit");    var inherit = getAttributeValue(ancestor, "hx-inherit");    if (initialElement !== ancestor) {      if (htmx.config.disableInheritance) {        if (          inherit &&          (inherit === "*" || inherit.split(" ").indexOf(attributeName) >= 0)        ) {          return attributeValue;        } else {          return null;        }      }      if (        disinherit &&        (disinherit === "*" ||          disinherit.split(" ").indexOf(attributeName) >= 0)      ) {        return "unset";      }    }    return attributeValue;  }  function getClosestAttributeValue(elt, attributeName) {    let closestAttr = null;    getClosestMatch(elt, function (e) {      return !!(closestAttr = getAttributeValueWithDisinheritance(        elt,        asElement(e),        attributeName,      ));    });    if (closestAttr !== "unset") {      return closestAttr;    }  }  function matches(elt, selector) {    const matchesFunction =      elt instanceof Element &&      (elt.matches ||        elt.matchesSelector ||        elt.msMatchesSelector ||        elt.mozMatchesSelector ||        elt.webkitMatchesSelector ||        elt.oMatchesSelector);    return !!matchesFunction && matchesFunction.call(elt, selector);  }  function getStartTag(str) {    const tagMatcher = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;    const match = tagMatcher.exec(str);    if (match) {      return match[1].toLowerCase();    } else {      return "";    }  }  function parseHTML(resp) {    const parser = new DOMParser();    return parser.parseFromString(resp, "text/html");  }  function takeChildrenFor(fragment, elt) {    while (elt.childNodes.length > 0) {      fragment.append(elt.childNodes[0]);    }  }  function duplicateScript(script) {    const newScript = getDocument().createElement("script");    forEach(script.attributes, function (attr) {      newScript.setAttribute(attr.name, attr.value);    });    newScript.textContent = script.textContent;    newScript.async = false;    if (htmx.config.inlineScriptNonce) {      newScript.nonce = htmx.config.inlineScriptNonce;    }    return newScript;  }  function isJavaScriptScriptNode(script) {    return (      script.matches("script") &&      (script.type === "text/javascript" ||        script.type === "module" ||        script.type === "")    );  }  function normalizeScriptTags(fragment) {    Array.from(fragment.querySelectorAll("script")).forEach((script) => {      if (isJavaScriptScriptNode(script)) {        const newScript = duplicateScript(script);        const parent = script.parentNode;        try {          parent.insertBefore(newScript, script);        } catch (e) {          logError(e);        } finally {          script.remove();        }      }    });  }  function makeFragment(response) {    const responseWithNoHead = response.replace(      /<head(\s[^>]*)?>[\s\S]*?<\/head>/i,      "",    );    const startTag = getStartTag(responseWithNoHead);    let fragment;    if (startTag === "html") {      fragment = new DocumentFragment();      const doc = parseHTML(response);      takeChildrenFor(fragment, doc.body);      fragment.title = doc.title;    } else if (startTag === "body") {      fragment = new DocumentFragment();      const doc = parseHTML(responseWithNoHead);      takeChildrenFor(fragment, doc.body);      fragment.title = doc.title;    } else {      const doc = parseHTML(        '<body><template class="internal-htmx-wrapper">' +          responseWithNoHead +          "</template></body>",      );      fragment = doc.querySelector("template").content;      fragment.title = doc.title;      var titleElement = fragment.querySelector("title");      if (titleElement && titleElement.parentNode === fragment) {        titleElement.remove();        fragment.title = titleElement.innerText;      }    }    if (fragment) {      if (htmx.config.allowScriptTags) {        normalizeScriptTags(fragment);      } else {        fragment          .querySelectorAll("script")          .forEach((script) => script.remove());      }    }    return fragment;  }  function maybeCall(func) {    if (func) {      func();    }  }  function isType(o, type) {    return Object.prototype.toString.call(o) === "[object " + type + "]";  }  function isFunction(o) {    return typeof o === "function";  }  function isRawObject(o) {    return isType(o, "Object");  }  function getInternalData(elt) {    const dataProp = "htmx-internal-data";    let data = elt[dataProp];    if (!data) {      data = elt[dataProp] = {};    }    return data;  }  function toArray(arr) {    const returnArr = [];    if (arr) {      for (let i = 0; i < arr.length; i++) {        returnArr.push(arr[i]);      }    }    return returnArr;  }  function forEach(arr, func) {    if (arr) {      for (let i = 0; i < arr.length; i++) {        func(arr[i]);      }    }  }  function isScrolledIntoView(el) {    const rect = el.getBoundingClientRect();    const elemTop = rect.top;    const elemBottom = rect.bottom;    return elemTop < window.innerHeight && elemBottom >= 0;  }  function bodyContains(elt) {    const rootNode = elt.getRootNode && elt.getRootNode();    if (rootNode && rootNode instanceof window.ShadowRoot) {      return getDocument().body.contains(rootNode.host);    } else {      return getDocument().body.contains(elt);    }  }  function splitOnWhitespace(trigger) {    return trigger.trim().split(/\s+/);  }  function mergeObjects(obj1, obj2) {    for (const key in obj2) {      if (obj2.hasOwnProperty(key)) {        obj1[key] = obj2[key];      }    }    return obj1;  }  function parseJSON(jString) {    try {      return JSON.parse(jString);    } catch (error) {      logError(error);      return null;    }  }  function canAccessLocalStorage() {    const test = "htmx:localStorageTest";    try {      localStorage.setItem(test, test);      localStorage.removeItem(test);      return true;    } catch (e) {      return false;    }  }  function normalizePath(path) {    try {      const url = new URL(path);      if (url) {        path = url.pathname + url.search;      }      if (!/^\/$/.test(path)) {        path = path.replace(/\/+$/, "");      }      return path;    } catch (e) {      return path;    }  }  function internalEval(str) {    return maybeEval(getDocument().body, function () {      return eval(str);    });  }  function onLoadHelper(callback) {    const value = htmx.on("htmx:load", function (evt) {      callback(evt.detail.elt);    });    return value;  }  function logAll() {    htmx.logger = function (elt, event, data) {      if (console) {        console.log(event, elt, data);      }    };  }  function logNone() {    htmx.logger = null;  }  function find(eltOrSelector, selector) {    if (typeof eltOrSelector !== "string") {      return eltOrSelector.querySelector(selector);    } else {      return find(getDocument(), eltOrSelector);    }  }  function findAll(eltOrSelector, selector) {    if (typeof eltOrSelector !== "string") {      return eltOrSelector.querySelectorAll(selector);    } else {      return findAll(getDocument(), eltOrSelector);    }  }  function getWindow() {    return window;  }  function removeElement(elt, delay) {    elt = resolveTarget(elt);    if (delay) {      getWindow().setTimeout(function () {        removeElement(elt);        elt = null;      }, delay);    } else {      parentElt(elt).removeChild(elt);    }  }  function asElement(elt) {    return elt instanceof Element ? elt : null;  }  function asHtmlElement(elt) {    return elt instanceof HTMLElement ? elt : null;  }  function asString(value) {    return typeof value === "string" ? value : null;  }  function asParentNode(elt) {    return elt instanceof Element ||      elt instanceof Document ||      elt instanceof DocumentFragment      ? elt      : null;  }  function addClassToElement(elt, clazz, delay) {    elt = asElement(resolveTarget(elt));    if (!elt) {      return;    }    if (delay) {      getWindow().setTimeout(function () {        addClassToElement(elt, clazz);        elt = null;      }, delay);    } else {      elt.classList && elt.classList.add(clazz);    }  }  function removeClassFromElement(node, clazz, delay) {    let elt = asElement(resolveTarget(node));    if (!elt) {      return;    }    if (delay) {      getWindow().setTimeout(function () {        removeClassFromElement(elt, clazz);        elt = null;      }, delay);    } else {      if (elt.classList) {        elt.classList.remove(clazz);        if (elt.classList.length === 0) {          elt.removeAttribute("class");        }      }    }  }  function toggleClassOnElement(elt, clazz) {    elt = resolveTarget(elt);    elt.classList.toggle(clazz);  }  function takeClassForElement(elt, clazz) {    elt = resolveTarget(elt);    forEach(elt.parentElement.children, function (child) {      removeClassFromElement(child, clazz);    });    addClassToElement(asElement(elt), clazz);  }  function closest(elt, selector) {    elt = asElement(resolveTarget(elt));    if (elt && elt.closest) {      return elt.closest(selector);    } else {      do {        if (elt == null || matches(elt, selector)) {          return elt;        }      } while ((elt = elt && asElement(parentElt(elt))));      return null;    }  }  function startsWith(str, prefix) {    return str.substring(0, prefix.length) === prefix;  }  function endsWith(str, suffix) {    return str.substring(str.length - suffix.length) === suffix;  }  function normalizeSelector(selector) {    const trimmedSelector = selector.trim();    if (startsWith(trimmedSelector, "<") && endsWith(trimmedSelector, "/>")) {      return trimmedSelector.substring(1, trimmedSelector.length - 2);    } else {      return trimmedSelector;    }  }  function querySelectorAllExt(elt, selector, global) {    elt = resolveTarget(elt);    if (selector.indexOf("closest ") === 0) {      return [closest(asElement(elt), normalizeSelector(selector.substr(8)))];    } else if (selector.indexOf("find ") === 0) {      return [find(asParentNode(elt), normalizeSelector(selector.substr(5)))];    } else if (selector === "next") {      return [asElement(elt).nextElementSibling];    } else if (selector.indexOf("next ") === 0) {      return [        scanForwardQuery(elt, normalizeSelector(selector.substr(5)), !!global),      ];    } else if (selector === "previous") {      return [asElement(elt).previousElementSibling];    } else if (selector.indexOf("previous ") === 0) {      return [        scanBackwardsQuery(          elt,          normalizeSelector(selector.substr(9)),          !!global,        ),      ];    } else if (selector === "document") {      return [document];    } else if (selector === "window") {      return [window];    } else if (selector === "body") {      return [document.body];    } else if (selector === "root") {      return [getRootNode(elt, !!global)];    } else if (selector === "host") {      return [elt.getRootNode().host];    } else if (selector.indexOf("global ") === 0) {      return querySelectorAllExt(elt, selector.slice(7), true);    } else {      return toArray(        asParentNode(getRootNode(elt, !!global)).querySelectorAll(          normalizeSelector(selector),        ),      );    }  }  var scanForwardQuery = function (start, match, global) {    const results = asParentNode(getRootNode(start, global)).querySelectorAll(      match,    );    for (let i = 0; i < results.length; i++) {      const elt = results[i];      if (        elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_PRECEDING      ) {        return elt;      }    }  };  var scanBackwardsQuery = function (start, match, global) {    const results = asParentNode(getRootNode(start, global)).querySelectorAll(      match,    );    for (let i = results.length - 1; i >= 0; i--) {      const elt = results[i];      if (        elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_FOLLOWING      ) {        return elt;      }    }  };  function querySelectorExt(eltOrSelector, selector) {    if (typeof eltOrSelector !== "string") {      return querySelectorAllExt(eltOrSelector, selector)[0];    } else {      return querySelectorAllExt(getDocument().body, eltOrSelector)[0];    }  }  function resolveTarget(eltOrSelector, context) {    if (typeof eltOrSelector === "string") {      return find(asParentNode(context) || document, eltOrSelector);    } else {      return eltOrSelector;    }  }  function processEventArgs(arg1, arg2, arg3, arg4) {    if (isFunction(arg2)) {      return {        target: getDocument().body,        event: asString(arg1),        listener: arg2,        options: arg3,      };    } else {      return {        target: resolveTarget(arg1),        event: asString(arg2),        listener: arg3,        options: arg4,      };    }  }  function addEventListenerImpl(arg1, arg2, arg3, arg4) {    ready(function () {      const eventArgs = processEventArgs(arg1, arg2, arg3, arg4);      eventArgs.target.addEventListener(        eventArgs.event,        eventArgs.listener,        eventArgs.options,      );    });    const b = isFunction(arg2);    return b ? arg2 : arg3;  }  function removeEventListenerImpl(arg1, arg2, arg3) {    ready(function () {      const eventArgs = processEventArgs(arg1, arg2, arg3);      eventArgs.target.removeEventListener(eventArgs.event, eventArgs.listener);    });    return isFunction(arg2) ? arg2 : arg3;  }  const DUMMY_ELT = getDocument().createElement("output");  function findAttributeTargets(elt, attrName) {    const attrTarget = getClosestAttributeValue(elt, attrName);    if (attrTarget) {      if (attrTarget === "this") {        return [findThisElement(elt, attrName)];      } else {        const result = querySelectorAllExt(elt, attrTarget);        if (result.length === 0) {          logError(            'The selector "' +              attrTarget +              '" on ' +              attrName +              " returned no matches!",          );          return [DUMMY_ELT];        } else {          return result;        }      }    }  }  function findThisElement(elt, attribute) {    return asElement(      getClosestMatch(elt, function (elt) {        return getAttributeValue(asElement(elt), attribute) != null;      }),    );  }  function getTarget(elt) {    const targetStr = getClosestAttributeValue(elt, "hx-target");    if (targetStr) {      if (targetStr === "this") {        return findThisElement(elt, "hx-target");      } else {        return querySelectorExt(elt, targetStr);      }    } else {      const data = getInternalData(elt);      if (data.boosted) {        return getDocument().body;      } else {        return elt;      }    }  }  function shouldSettleAttribute(name) {    const attributesToSettle = htmx.config.attributesToSettle;    for (let i = 0; i < attributesToSettle.length; i++) {      if (name === attributesToSettle[i]) {        return true;      }    }    return false;  }  function cloneAttributes(mergeTo, mergeFrom) {    forEach(mergeTo.attributes, function (attr) {      if (        !mergeFrom.hasAttribute(attr.name) &&        shouldSettleAttribute(attr.name)      ) {        mergeTo.removeAttribute(attr.name);      }    });    forEach(mergeFrom.attributes, function (attr) {      if (shouldSettleAttribute(attr.name)) {        mergeTo.setAttribute(attr.name, attr.value);      }    });  }  function isInlineSwap(swapStyle, target) {    const extensions = getExtensions(target);    for (let i = 0; i < extensions.length; i++) {      const extension = extensions[i];      try {        if (extension.isInlineSwap(swapStyle)) {          return true;        }      } catch (e) {        logError(e);      }    }    return swapStyle === "outerHTML";  }  function oobSwap(oobValue, oobElement, settleInfo, rootNode) {    rootNode = rootNode || getDocument();    let selector = "#" + getRawAttribute(oobElement, "id");    let swapStyle = "outerHTML";    if (oobValue === "true") {    } else if (oobValue.indexOf(":") > 0) {      swapStyle = oobValue.substr(0, oobValue.indexOf(":"));      selector = oobValue.substr(oobValue.indexOf(":") + 1, oobValue.length);    } else {      swapStyle = oobValue;    }    oobElement.removeAttribute("hx-swap-oob");    oobElement.removeAttribute("data-hx-swap-oob");    const targets = querySelectorAllExt(rootNode, selector, false);    if (targets) {      forEach(targets, function (target) {        let fragment;        const oobElementClone = oobElement.cloneNode(true);        fragment = getDocument().createDocumentFragment();        fragment.appendChild(oobElementClone);        if (!isInlineSwap(swapStyle, target)) {          fragment = asParentNode(oobElementClone);        }        const beforeSwapDetails = { shouldSwap: true, target, fragment };        if (!triggerEvent(target, "htmx:oobBeforeSwap", beforeSwapDetails))          return;        target = beforeSwapDetails.target;        if (beforeSwapDetails.shouldSwap) {          handlePreservedElements(fragment);          swapWithStyle(swapStyle, target, target, fragment, settleInfo);          restorePreservedElements();        }        forEach(settleInfo.elts, function (elt) {          triggerEvent(elt, "htmx:oobAfterSwap", beforeSwapDetails);        });      });      oobElement.parentNode.removeChild(oobElement);    } else {      oobElement.parentNode.removeChild(oobElement);      triggerErrorEvent(getDocument().body, "htmx:oobErrorNoTarget", {        content: oobElement,      });    }    return oobValue;  }  function restorePreservedElements() {    const pantry = find("#--htmx-preserve-pantry--");    if (pantry) {      for (const preservedElt of [...pantry.children]) {        const existingElement = find("#" + preservedElt.id);        existingElement.parentNode.moveBefore(preservedElt, existingElement);        existingElement.remove();      }      pantry.remove();    }  }  function handlePreservedElements(fragment) {    forEach(      findAll(fragment, "[hx-preserve], [data-hx-preserve]"),      function (preservedElt) {        const id = getAttributeValue(preservedElt, "id");        const existingElement = getDocument().getElementById(id);        if (existingElement != null) {          if (preservedElt.moveBefore) {            let pantry = find("#--htmx-preserve-pantry--");            if (pantry == null) {              getDocument().body.insertAdjacentHTML(                "afterend",                "<div id='--htmx-preserve-pantry--'></div>",              );              pantry = find("#--htmx-preserve-pantry--");            }            pantry.moveBefore(existingElement, null);          } else {            preservedElt.parentNode.replaceChild(existingElement, preservedElt);          }        }      },    );  }  function handleAttributes(parentNode, fragment, settleInfo) {    forEach(fragment.querySelectorAll("[id]"), function (newNode) {      const id = getRawAttribute(newNode, "id");      if (id && id.length > 0) {        const normalizedId = id.replace("'", "\\'");        const normalizedTag = newNode.tagName.replace(":", "\\:");        const parentElt = asParentNode(parentNode);        const oldNode =          parentElt &&          parentElt.querySelector(            normalizedTag + "[id='" + normalizedId + "']",          );        if (oldNode && oldNode !== parentElt) {          const newAttributes = newNode.cloneNode();          cloneAttributes(newNode, oldNode);          settleInfo.tasks.push(function () {            cloneAttributes(newNode, newAttributes);          });        }      }    });  }  function makeAjaxLoadTask(child) {    return function () {      removeClassFromElement(child, htmx.config.addedClass);      processNode(asElement(child));      processFocus(asParentNode(child));      triggerEvent(child, "htmx:load");    };  }  function processFocus(child) {    const autofocus = "[autofocus]";    const autoFocusedElt = asHtmlElement(      matches(child, autofocus) ? child : child.querySelector(autofocus),    );    if (autoFocusedElt != null) {      autoFocusedElt.focus();    }  }  function insertNodesBefore(parentNode, insertBefore, fragment, settleInfo) {    handleAttributes(parentNode, fragment, settleInfo);    while (fragment.childNodes.length > 0) {      const child = fragment.firstChild;      addClassToElement(asElement(child), htmx.config.addedClass);      parentNode.insertBefore(child, insertBefore);      if (        child.nodeType !== Node.TEXT_NODE &&        child.nodeType !== Node.COMMENT_NODE      ) {        settleInfo.tasks.push(makeAjaxLoadTask(child));      }    }  }  function stringHash(string, hash) {    let char = 0;    while (char < string.length) {      hash = ((hash << 5) - hash + string.charCodeAt(char++)) | 0;    }    return hash;  }  function attributeHash(elt) {    let hash = 0;    if (elt.attributes) {      for (let i = 0; i < elt.attributes.length; i++) {        const attribute = elt.attributes[i];        if (attribute.value) {          hash = stringHash(attribute.name, hash);          hash = stringHash(attribute.value, hash);        }      }    }    return hash;  }  function deInitOnHandlers(elt) {    const internalData = getInternalData(elt);    if (internalData.onHandlers) {      for (let i = 0; i < internalData.onHandlers.length; i++) {        const handlerInfo = internalData.onHandlers[i];        removeEventListenerImpl(elt, handlerInfo.event, handlerInfo.listener);      }      delete internalData.onHandlers;    }  }  function deInitNode(element) {    const internalData = getInternalData(element);    if (internalData.timeout) {      clearTimeout(internalData.timeout);    }    if (internalData.listenerInfos) {      forEach(internalData.listenerInfos, function (info) {        if (info.on) {          removeEventListenerImpl(info.on, info.trigger, info.listener);        }      });    }    deInitOnHandlers(element);    forEach(Object.keys(internalData), function (key) {      delete internalData[key];    });  }  function cleanUpElement(element) {    triggerEvent(element, "htmx:beforeCleanupElement");    deInitNode(element);    if (element.children) {      forEach(element.children, function (child) {        cleanUpElement(child);      });    }  }  function swapOuterHTML(target, fragment, settleInfo) {    if (target instanceof Element && target.tagName === "BODY") {      return swapInnerHTML(target, fragment, settleInfo);    }    let newElt;    const eltBeforeNewContent = target.previousSibling;    const parentNode = parentElt(target);    if (!parentNode) {      return;    }    insertNodesBefore(parentNode, target, fragment, settleInfo);    if (eltBeforeNewContent == null) {      newElt = parentNode.firstChild;    } else {      newElt = eltBeforeNewContent.nextSibling;    }    settleInfo.elts = settleInfo.elts.filter(function (e) {      return e !== target;    });    while (newElt && newElt !== target) {      if (newElt instanceof Element) {        settleInfo.elts.push(newElt);      }      newElt = newElt.nextSibling;    }    cleanUpElement(target);    if (target instanceof Element) {      target.remove();    } else {      target.parentNode.removeChild(target);    }  }  function swapAfterBegin(target, fragment, settleInfo) {    return insertNodesBefore(target, target.firstChild, fragment, settleInfo);  }  function swapBeforeBegin(target, fragment, settleInfo) {    return insertNodesBefore(parentElt(target), target, fragment, settleInfo);  }  function swapBeforeEnd(target, fragment, settleInfo) {    return insertNodesBefore(target, null, fragment, settleInfo);  }  function swapAfterEnd(target, fragment, settleInfo) {    return insertNodesBefore(      parentElt(target),      target.nextSibling,      fragment,      settleInfo,    );  }  function swapDelete(target) {    cleanUpElement(target);    const parent = parentElt(target);    if (parent) {      return parent.removeChild(target);    }  }  function swapInnerHTML(target, fragment, settleInfo) {    const firstChild = target.firstChild;    insertNodesBefore(target, firstChild, fragment, settleInfo);    if (firstChild) {      while (firstChild.nextSibling) {        cleanUpElement(firstChild.nextSibling);        target.removeChild(firstChild.nextSibling);      }      cleanUpElement(firstChild);      target.removeChild(firstChild);    }  }  function swapWithStyle(swapStyle, elt, target, fragment, settleInfo) {    switch (swapStyle) {      case "none":        return;      case "outerHTML":        swapOuterHTML(target, fragment, settleInfo);        return;      case "afterbegin":        swapAfterBegin(target, fragment, settleInfo);        return;      case "beforebegin":        swapBeforeBegin(target, fragment, settleInfo);        return;      case "beforeend":        swapBeforeEnd(target, fragment, settleInfo);        return;      case "afterend":        swapAfterEnd(target, fragment, settleInfo);        return;      case "delete":        swapDelete(target);        return;      default:        var extensions = getExtensions(elt);        for (let i = 0; i < extensions.length; i++) {          const ext = extensions[i];          try {            const newElements = ext.handleSwap(              swapStyle,              target,              fragment,              settleInfo,            );            if (newElements) {              if (Array.isArray(newElements)) {                for (let j = 0; j < newElements.length; j++) {                  const child = newElements[j];                  if (                    child.nodeType !== Node.TEXT_NODE &&                    child.nodeType !== Node.COMMENT_NODE                  ) {                    settleInfo.tasks.push(makeAjaxLoadTask(child));                  }                }              }              return;            }          } catch (e) {            logError(e);          }        }        if (swapStyle === "innerHTML") {          swapInnerHTML(target, fragment, settleInfo);        } else {          swapWithStyle(            htmx.config.defaultSwapStyle,            elt,            target,            fragment,            settleInfo,          );        }    }  }  function findAndSwapOobElements(fragment, settleInfo, rootNode) {    var oobElts = findAll(fragment, "[hx-swap-oob], [data-hx-swap-oob]");    forEach(oobElts, function (oobElement) {      if (        htmx.config.allowNestedOobSwaps ||        oobElement.parentElement === null      ) {        const oobValue = getAttributeValue(oobElement, "hx-swap-oob");        if (oobValue != null) {          oobSwap(oobValue, oobElement, settleInfo, rootNode);        }      } else {        oobElement.removeAttribute("hx-swap-oob");        oobElement.removeAttribute("data-hx-swap-oob");      }    });    return oobElts.length > 0;  }  function swap(target, content, swapSpec, swapOptions) {    if (!swapOptions) {      swapOptions = {};    }    target = resolveTarget(target);    const rootNode = swapOptions.contextElement      ? getRootNode(swapOptions.contextElement, false)      : getDocument();    const activeElt = document.activeElement;    let selectionInfo = {};    try {      selectionInfo = {        elt: activeElt,        start: activeElt ? activeElt.selectionStart : null,        end: activeElt ? activeElt.selectionEnd : null,      };    } catch (e) {}    const settleInfo = makeSettleInfo(target);    if (swapSpec.swapStyle === "textContent") {      target.textContent = content;    } else {      let fragment = makeFragment(content);      settleInfo.title = fragment.title;      if (swapOptions.selectOOB) {        const oobSelectValues = swapOptions.selectOOB.split(",");        for (let i = 0; i < oobSelectValues.length; i++) {          const oobSelectValue = oobSelectValues[i].split(":", 2);          let id = oobSelectValue[0].trim();          if (id.indexOf("#") === 0) {            id = id.substring(1);          }          const oobValue = oobSelectValue[1] || "true";          const oobElement = fragment.querySelector("#" + id);          if (oobElement) {            oobSwap(oobValue, oobElement, settleInfo, rootNode);          }        }      }      findAndSwapOobElements(fragment, settleInfo, rootNode);      forEach(findAll(fragment, "template"), function (template) {        if (findAndSwapOobElements(template.content, settleInfo, rootNode)) {          template.remove();        }      });      if (swapOptions.select) {        const newFragment = getDocument().createDocumentFragment();        forEach(fragment.querySelectorAll(swapOptions.select), function (node) {          newFragment.appendChild(node);        });        fragment = newFragment;      }      handlePreservedElements(fragment);      swapWithStyle(        swapSpec.swapStyle,        swapOptions.contextElement,        target,        fragment,        settleInfo,      );      restorePreservedElements();    }    if (      selectionInfo.elt &&      !bodyContains(selectionInfo.elt) &&      getRawAttribute(selectionInfo.elt, "id")    ) {      const newActiveElt = document.getElementById(        getRawAttribute(selectionInfo.elt, "id"),      );      const focusOptions = {        preventScroll:          swapSpec.focusScroll !== undefined            ? !swapSpec.focusScroll            : !htmx.config.defaultFocusScroll,      };      if (newActiveElt) {        if (selectionInfo.start && newActiveElt.setSelectionRange) {          try {            newActiveElt.setSelectionRange(              selectionInfo.start,              selectionInfo.end,            );          } catch (e) {}        }        newActiveElt.focus(focusOptions);      }    }    target.classList.remove(htmx.config.swappingClass);    forEach(settleInfo.elts, function (elt) {      if (elt.classList) {        elt.classList.add(htmx.config.settlingClass);      }      triggerEvent(elt, "htmx:afterSwap", swapOptions.eventInfo);    });    if (swapOptions.afterSwapCallback) {      swapOptions.afterSwapCallback();    }    if (!swapSpec.ignoreTitle) {      handleTitle(settleInfo.title);    }    const doSettle = function () {      forEach(settleInfo.tasks, function (task) {        task.call();      });      forEach(settleInfo.elts, function (elt) {        if (elt.classList) {          elt.classList.remove(htmx.config.settlingClass);        }        triggerEvent(elt, "htmx:afterSettle", swapOptions.eventInfo);      });      if (swapOptions.anchor) {        const anchorTarget = asElement(resolveTarget("#" + swapOptions.anchor));        if (anchorTarget) {          anchorTarget.scrollIntoView({ block: "start", behavior: "auto" });        }      }      updateScrollState(settleInfo.elts, swapSpec);      if (swapOptions.afterSettleCallback) {        swapOptions.afterSettleCallback();      }    };    if (swapSpec.settleDelay > 0) {      getWindow().setTimeout(doSettle, swapSpec.settleDelay);    } else {      doSettle();    }  }  function handleTriggerHeader(xhr, header, elt) {    const triggerBody = xhr.getResponseHeader(header);    if (triggerBody.indexOf("{") === 0) {      const triggers = parseJSON(triggerBody);      for (const eventName in triggers) {        if (triggers.hasOwnProperty(eventName)) {          let detail = triggers[eventName];          if (isRawObject(detail)) {            elt = detail.target !== undefined ? detail.target : elt;          } else {            detail = { value: detail };          }          triggerEvent(elt, eventName, detail);        }      }    } else {      const eventNames = triggerBody.split(",");      for (let i = 0; i < eventNames.length; i++) {        triggerEvent(elt, eventNames[i].trim(), []);      }    }  }  const WHITESPACE = /\s/;  const WHITESPACE_OR_COMMA = /[\s,]/;  const SYMBOL_START = /[_$a-zA-Z]/;  const SYMBOL_CONT = /[_$a-zA-Z0-9]/;  const STRINGISH_START = ['"', "'", "/"];  const NOT_WHITESPACE = /[^\s]/;  const COMBINED_SELECTOR_START = /[{(]/;  const COMBINED_SELECTOR_END = /[})]/;  function tokenizeString(str) {    const tokens = [];    let position = 0;    while (position < str.length) {      if (SYMBOL_START.exec(str.charAt(position))) {        var startPosition = position;        while (SYMBOL_CONT.exec(str.charAt(position + 1))) {          position++;        }        tokens.push(str.substr(startPosition, position - startPosition + 1));      } else if (STRINGISH_START.indexOf(str.charAt(position)) !== -1) {        const startChar = str.charAt(position);        var startPosition = position;        position++;        while (position < str.length && str.charAt(position) !== startChar) {          if (str.charAt(position) === "\\") {            position++;          }          position++;        }        tokens.push(str.substr(startPosition, position - startPosition + 1));      } else {        const symbol = str.charAt(position);        tokens.push(symbol);      }      position++;    }    return tokens;  }  function isPossibleRelativeReference(token, last, paramName) {    return (      SYMBOL_START.exec(token.charAt(0)) &&      token !== "true" &&      token !== "false" &&      token !== "this" &&      token !== paramName &&      last !== "."    );  }  function maybeGenerateConditional(elt, tokens, paramName) {    if (tokens[0] === "[") {      tokens.shift();      let bracketCount = 1;      let conditionalSource = " return (function(" + paramName + "){ return (";      let last = null;      while (tokens.length > 0) {        const token = tokens[0];        if (token === "]") {          bracketCount--;          if (bracketCount === 0) {            if (last === null) {              conditionalSource = conditionalSource + "true";            }            tokens.shift();            conditionalSource += ")})";            try {              const conditionFunction = maybeEval(                elt,                function () {                  return Function(conditionalSource)();                },                function () {                  return true;                },              );              conditionFunction.source = conditionalSource;              return conditionFunction;            } catch (e) {              triggerErrorEvent(getDocument().body, "htmx:syntax:error", {                error: e,                source: conditionalSource,              });              return null;            }          }        } else if (token === "[") {          bracketCount++;        }        if (isPossibleRelativeReference(token, last, paramName)) {          conditionalSource +=            "((" +            paramName +            "." +            token +            ") ? (" +            paramName +            "." +            token +            ") : (window." +            token +            "))";        } else {          conditionalSource = conditionalSource + token;        }        last = tokens.shift();      }    }  }  function consumeUntil(tokens, match) {    let result = "";    while (tokens.length > 0 && !match.test(tokens[0])) {      result += tokens.shift();    }    return result;  }  function consumeCSSSelector(tokens) {    let result;    if (tokens.length > 0 && COMBINED_SELECTOR_START.test(tokens[0])) {      tokens.shift();      result = consumeUntil(tokens, COMBINED_SELECTOR_END).trim();      tokens.shift();    } else {      result = consumeUntil(tokens, WHITESPACE_OR_COMMA);    }    return result;  }  const INPUT_SELECTOR = "input, textarea, select";  function parseAndCacheTrigger(elt, explicitTrigger, cache) {    const triggerSpecs = [];    const tokens = tokenizeString(explicitTrigger);    do {      consumeUntil(tokens, NOT_WHITESPACE);      const initialLength = tokens.length;      const trigger = consumeUntil(tokens, /[,\[\s]/);      if (trigger !== "") {        if (trigger === "every") {          const every = { trigger: "every" };          consumeUntil(tokens, NOT_WHITESPACE);          every.pollInterval = parseInterval(consumeUntil(tokens, /[,\[\s]/));          consumeUntil(tokens, NOT_WHITESPACE);          var eventFilter = maybeGenerateConditional(elt, tokens, "event");          if (eventFilter) {            every.eventFilter = eventFilter;          }          triggerSpecs.push(every);        } else {          const triggerSpec = { trigger };          var eventFilter = maybeGenerateConditional(elt, tokens, "event");          if (eventFilter) {            triggerSpec.eventFilter = eventFilter;          }          consumeUntil(tokens, NOT_WHITESPACE);          while (tokens.length > 0 && tokens[0] !== ",") {            const token = tokens.shift();            if (token === "changed") {              triggerSpec.changed = true;            } else if (token === "once") {              triggerSpec.once = true;            } else if (token === "consume") {              triggerSpec.consume = true;            } else if (token === "delay" && tokens[0] === ":") {              tokens.shift();              triggerSpec.delay = parseInterval(                consumeUntil(tokens, WHITESPACE_OR_COMMA),              );            } else if (token === "from" && tokens[0] === ":") {              tokens.shift();              if (COMBINED_SELECTOR_START.test(tokens[0])) {                var from_arg = consumeCSSSelector(tokens);              } else {                var from_arg = consumeUntil(tokens, WHITESPACE_OR_COMMA);                if (                  from_arg === "closest" ||                  from_arg === "find" ||                  from_arg === "next" ||                  from_arg === "previous"                ) {                  tokens.shift();                  const selector = consumeCSSSelector(tokens);                  if (selector.length > 0) {                    from_arg += " " + selector;                  }                }              }              triggerSpec.from = from_arg;            } else if (token === "target" && tokens[0] === ":") {              tokens.shift();              triggerSpec.target = consumeCSSSelector(tokens);            } else if (token === "throttle" && tokens[0] === ":") {              tokens.shift();              triggerSpec.throttle = parseInterval(                consumeUntil(tokens, WHITESPACE_OR_COMMA),              );            } else if (token === "queue" && tokens[0] === ":") {              tokens.shift();              triggerSpec.queue = consumeUntil(tokens, WHITESPACE_OR_COMMA);            } else if (token === "root" && tokens[0] === ":") {              tokens.shift();              triggerSpec[token] = consumeCSSSelector(tokens);            } else if (token === "threshold" && tokens[0] === ":") {              tokens.shift();              triggerSpec[token] = consumeUntil(tokens, WHITESPACE_OR_COMMA);            } else {              triggerErrorEvent(elt, "htmx:syntax:error", {                token: tokens.shift(),              });            }            consumeUntil(tokens, NOT_WHITESPACE);          }          triggerSpecs.push(triggerSpec);        }      }      if (tokens.length === initialLength) {        triggerErrorEvent(elt, "htmx:syntax:error", { token: tokens.shift() });      }      consumeUntil(tokens, NOT_WHITESPACE);    } while (tokens[0] === "," && tokens.shift());    if (cache) {      cache[explicitTrigger] = triggerSpecs;    }    return triggerSpecs;  }  function getTriggerSpecs(elt) {    const explicitTrigger = getAttributeValue(elt, "hx-trigger");    let triggerSpecs = [];    if (explicitTrigger) {      const cache = htmx.config.triggerSpecsCache;      triggerSpecs =        (cache && cache[explicitTrigger]) ||        parseAndCacheTrigger(elt, explicitTrigger, cache);    }    if (triggerSpecs.length > 0) {      return triggerSpecs;    } else if (matches(elt, "form")) {      return [{ trigger: "submit" }];    } else if (matches(elt, 'input[type="button"], input[type="submit"]')) {      return [{ trigger: "click" }];    } else if (matches(elt, INPUT_SELECTOR)) {      return [{ trigger: "change" }];    } else {      return [{ trigger: "click" }];    }  }  function cancelPolling(elt) {    getInternalData(elt).cancelled = true;  }  function processPolling(elt, handler, spec) {    const nodeData = getInternalData(elt);    nodeData.timeout = getWindow().setTimeout(function () {      if (bodyContains(elt) && nodeData.cancelled !== true) {        if (          !maybeFilterEvent(            spec,            elt,            makeEvent("hx:poll:trigger", { triggerSpec: spec, target: elt }),          )        ) {          handler(elt);        }        processPolling(elt, handler, spec);      }    }, spec.pollInterval);  }  function isLocalLink(elt) {    return (      location.hostname === elt.hostname &&      getRawAttribute(elt, "href") &&      getRawAttribute(elt, "href").indexOf("#") !== 0    );  }  function eltIsDisabled(elt) {    return closest(elt, htmx.config.disableSelector);  }  function boostElement(elt, nodeData, triggerSpecs) {    if (      (elt instanceof HTMLAnchorElement &&        isLocalLink(elt) &&        (elt.target === "" || elt.target === "_self")) ||      (elt.tagName === "FORM" &&        String(getRawAttribute(elt, "method")).toLowerCase() !== "dialog")    ) {      nodeData.boosted = true;      let verb, path;      if (elt.tagName === "A") {        verb = "get";        path = getRawAttribute(elt, "href");      } else {        const rawAttribute = getRawAttribute(elt, "method");        verb = rawAttribute ? rawAttribute.toLowerCase() : "get";        path = getRawAttribute(elt, "action");        if (verb === "get" && path.includes("?")) {          path = path.replace(/\?[^#]+/, "");        }      }      triggerSpecs.forEach(function (triggerSpec) {        addEventListener(          elt,          function (node, evt) {            const elt = asElement(node);            if (eltIsDisabled(elt)) {              cleanUpElement(elt);              return;            }            issueAjaxRequest(verb, path, elt, evt);          },          nodeData,          triggerSpec,          true,        );      });    }  }  function shouldCancel(evt, node) {    const elt = asElement(node);    if (!elt) {      return false;    }    if (evt.type === "submit" || evt.type === "click") {      if (elt.tagName === "FORM") {        return true;      }      if (        matches(elt, 'input[type="submit"], button') &&        closest(elt, "form") !== null      ) {        return true;      }      if (        elt instanceof HTMLAnchorElement &&        elt.href &&        (elt.getAttribute("href") === "#" ||          elt.getAttribute("href").indexOf("#") !== 0)      ) {        return true;      }    }    return false;  }  function ignoreBoostedAnchorCtrlClick(elt, evt) {    return (      getInternalData(elt).boosted &&      elt instanceof HTMLAnchorElement &&      evt.type === "click" &&      (evt.ctrlKey || evt.metaKey)    );  }  function maybeFilterEvent(triggerSpec, elt, evt) {    const eventFilter = triggerSpec.eventFilter;    if (eventFilter) {      try {        return eventFilter.call(elt, evt) !== true;      } catch (e) {        const source = eventFilter.source;        triggerErrorEvent(getDocument().body, "htmx:eventFilter:error", {          error: e,          source,        });        return true;      }    }    return false;  }  function addEventListener(    elt,    handler,    nodeData,    triggerSpec,    explicitCancel,  ) {    const elementData = getInternalData(elt);    let eltsToListenOn;    if (triggerSpec.from) {      eltsToListenOn = querySelectorAllExt(elt, triggerSpec.from);    } else {      eltsToListenOn = [elt];    }    if (triggerSpec.changed) {      if (!("lastValue" in elementData)) {        elementData.lastValue = new WeakMap();      }      eltsToListenOn.forEach(function (eltToListenOn) {        if (!elementData.lastValue.has(triggerSpec)) {          elementData.lastValue.set(triggerSpec, new WeakMap());        }        elementData.lastValue          .get(triggerSpec)          .set(eltToListenOn, eltToListenOn.value);      });    }    forEach(eltsToListenOn, function (eltToListenOn) {      const eventListener = function (evt) {        if (!bodyContains(elt)) {          eltToListenOn.removeEventListener(triggerSpec.trigger, eventListener);          return;        }        if (ignoreBoostedAnchorCtrlClick(elt, evt)) {          return;        }        if (explicitCancel || shouldCancel(evt, elt)) {          evt.preventDefault();        }        if (maybeFilterEvent(triggerSpec, elt, evt)) {          return;        }        const eventData = getInternalData(evt);        eventData.triggerSpec = triggerSpec;        if (eventData.handledFor == null) {          eventData.handledFor = [];        }        if (eventData.handledFor.indexOf(elt) < 0) {          eventData.handledFor.push(elt);          if (triggerSpec.consume) {            evt.stopPropagation();          }          if (triggerSpec.target && evt.target) {            if (!matches(asElement(evt.target), triggerSpec.target)) {              return;            }          }          if (triggerSpec.once) {            if (elementData.triggeredOnce) {              return;            } else {              elementData.triggeredOnce = true;            }          }          if (triggerSpec.changed) {            const node = event.target;            const value = node.value;            const lastValue = elementData.lastValue.get(triggerSpec);            if (lastValue.has(node) && lastValue.get(node) === value) {              return;            }            lastValue.set(node, value);          }          if (elementData.delayed) {            clearTimeout(elementData.delayed);          }          if (elementData.throttle) {            return;          }          if (triggerSpec.throttle > 0) {            if (!elementData.throttle) {              triggerEvent(elt, "htmx:trigger");              handler(elt, evt);              elementData.throttle = getWindow().setTimeout(function () {                elementData.throttle = null;              }, triggerSpec.throttle);            }          } else if (triggerSpec.delay > 0) {            elementData.delayed = getWindow().setTimeout(function () {              triggerEvent(elt, "htmx:trigger");              handler(elt, evt);            }, triggerSpec.delay);          } else {            triggerEvent(elt, "htmx:trigger");            handler(elt, evt);          }        }      };      if (nodeData.listenerInfos == null) {        nodeData.listenerInfos = [];      }      nodeData.listenerInfos.push({        trigger: triggerSpec.trigger,        listener: eventListener,        on: eltToListenOn,      });      eltToListenOn.addEventListener(triggerSpec.trigger, eventListener);    });  }  let windowIsScrolling = false;  let scrollHandler = null;  function initScrollHandler() {    if (!scrollHandler) {      scrollHandler = function () {        windowIsScrolling = true;      };      window.addEventListener("scroll", scrollHandler);      window.addEventListener("resize", scrollHandler);      setInterval(function () {        if (windowIsScrolling) {          windowIsScrolling = false;          forEach(            getDocument().querySelectorAll(              "[hx-trigger*='revealed'],[data-hx-trigger*='revealed']",            ),            function (elt) {              maybeReveal(elt);            },          );        }      }, 200);    }  }  function maybeReveal(elt) {    if (!hasAttribute(elt, "data-hx-revealed") && isScrolledIntoView(elt)) {      elt.setAttribute("data-hx-revealed", "true");      const nodeData = getInternalData(elt);      if (nodeData.initHash) {        triggerEvent(elt, "revealed");      } else {        elt.addEventListener(          "htmx:afterProcessNode",          function () {            triggerEvent(elt, "revealed");          },          { once: true },        );      }    }  }  function loadImmediately(elt, handler, nodeData, delay) {    const load = function () {      if (!nodeData.loaded) {        nodeData.loaded = true;        handler(elt);      }    };    if (delay > 0) {      getWindow().setTimeout(load, delay);    } else {      load();    }  }  function processVerbs(elt, nodeData, triggerSpecs) {    let explicitAction = false;    forEach(VERBS, function (verb) {      if (hasAttribute(elt, "hx-" + verb)) {        const path = getAttributeValue(elt, "hx-" + verb);        explicitAction = true;        nodeData.path = path;        nodeData.verb = verb;        triggerSpecs.forEach(function (triggerSpec) {          addTriggerHandler(elt, triggerSpec, nodeData, function (node, evt) {            const elt = asElement(node);            if (closest(elt, htmx.config.disableSelector)) {              cleanUpElement(elt);              return;            }            issueAjaxRequest(verb, path, elt, evt);          });        });      }    });    return explicitAction;  }  function addTriggerHandler(elt, triggerSpec, nodeData, handler) {    if (triggerSpec.trigger === "revealed") {      initScrollHandler();      addEventListener(elt, handler, nodeData, triggerSpec);      maybeReveal(asElement(elt));    } else if (triggerSpec.trigger === "intersect") {      const observerOptions = {};      if (triggerSpec.root) {        observerOptions.root = querySelectorExt(elt, triggerSpec.root);      }      if (triggerSpec.threshold) {        observerOptions.threshold = parseFloat(triggerSpec.threshold);      }      const observer = new IntersectionObserver(function (entries) {        for (let i = 0; i < entries.length; i++) {          const entry = entries[i];          if (entry.isIntersecting) {            triggerEvent(elt, "intersect");            break;          }        }      }, observerOptions);      observer.observe(asElement(elt));      addEventListener(asElement(elt), handler, nodeData, triggerSpec);    } else if (triggerSpec.trigger === "load") {      if (!maybeFilterEvent(triggerSpec, elt, makeEvent("load", { elt }))) {        loadImmediately(asElement(elt), handler, nodeData, triggerSpec.delay);      }    } else if (triggerSpec.pollInterval > 0) {      nodeData.polling = true;      processPolling(asElement(elt), handler, triggerSpec);    } else {      addEventListener(elt, handler, nodeData, triggerSpec);    }  }  function shouldProcessHxOn(node) {    const elt = asElement(node);    if (!elt) {      return false;    }    const attributes = elt.attributes;    for (let j = 0; j < attributes.length; j++) {      const attrName = attributes[j].name;      if (        startsWith(attrName, "hx-on:") ||        startsWith(attrName, "data-hx-on:") ||        startsWith(attrName, "hx-on-") ||        startsWith(attrName, "data-hx-on-")      ) {        return true;      }    }    return false;  }  const HX_ON_QUERY = new XPathEvaluator().createExpression(    './/*[@*[ starts-with(name(), "hx-on:") or starts-with(name(), "data-hx-on:") or' +      ' starts-with(name(), "hx-on-") or starts-with(name(), "data-hx-on-") ]]',  );  function processHXOnRoot(elt, elements) {    if (shouldProcessHxOn(elt)) {      elements.push(asElement(elt));    }    const iter = HX_ON_QUERY.evaluate(elt);    let node = null;    while ((node = iter.iterateNext())) elements.push(asElement(node));  }  function findHxOnWildcardElements(elt) {    const elements = [];    if (elt instanceof DocumentFragment) {      for (const child of elt.childNodes) {        processHXOnRoot(child, elements);      }    } else {      processHXOnRoot(elt, elements);    }    return elements;  }  function findElementsToProcess(elt) {    if (elt.querySelectorAll) {      const boostedSelector =        ", [hx-boost] a, [data-hx-boost] a, a[hx-boost], a[data-hx-boost]";      const extensionSelectors = [];      for (const e in extensions) {        const extension = extensions[e];        if (extension.getSelectors) {          var selectors = extension.getSelectors();          if (selectors) {            extensionSelectors.push(selectors);          }        }      }      const results = elt.querySelectorAll(        VERB_SELECTOR +          boostedSelector +          ", form, [type='submit']," +          " [hx-ext], [data-hx-ext], [hx-trigger], [data-hx-trigger]" +          extensionSelectors            .flat()            .map((s) => ", " + s)            .join(""),      );      return results;    } else {      return [];    }  }  function maybeSetLastButtonClicked(evt) {    const elt = closest(asElement(evt.target), "button, input[type='submit']");    const internalData = getRelatedFormData(evt);    if (internalData) {      internalData.lastButtonClicked = elt;    }  }  function maybeUnsetLastButtonClicked(evt) {    const internalData = getRelatedFormData(evt);    if (internalData) {      internalData.lastButtonClicked = null;    }  }  function getRelatedFormData(evt) {    const elt = closest(asElement(evt.target), "button, input[type='submit']");    if (!elt) {      return;    }    const form =      resolveTarget("#" + getRawAttribute(elt, "form"), elt.getRootNode()) ||      closest(elt, "form");    if (!form) {      return;    }    return getInternalData(form);  }  function initButtonTracking(elt) {    elt.addEventListener("click", maybeSetLastButtonClicked);    elt.addEventListener("focusin", maybeSetLastButtonClicked);    elt.addEventListener("focusout", maybeUnsetLastButtonClicked);  }  function addHxOnEventHandler(elt, eventName, code) {    const nodeData = getInternalData(elt);    if (!Array.isArray(nodeData.onHandlers)) {      nodeData.onHandlers = [];    }    let func;    const listener = function (e) {      maybeEval(elt, function () {        if (eltIsDisabled(elt)) {          return;        }        if (!func) {          func = new Function("event", code);        }        func.call(elt, e);      });    };    elt.addEventListener(eventName, listener);    nodeData.onHandlers.push({ event: eventName, listener });  }  function processHxOnWildcard(elt) {    deInitOnHandlers(elt);    for (let i = 0; i < elt.attributes.length; i++) {      const name = elt.attributes[i].name;      const value = elt.attributes[i].value;      if (startsWith(name, "hx-on") || startsWith(name, "data-hx-on")) {        const afterOnPosition = name.indexOf("-on") + 3;        const nextChar = name.slice(afterOnPosition, afterOnPosition + 1);        if (nextChar === "-" || nextChar === ":") {          let eventName = name.slice(afterOnPosition + 1);          if (startsWith(eventName, ":")) {            eventName = "htmx" + eventName;          } else if (startsWith(eventName, "-")) {            eventName = "htmx:" + eventName.slice(1);          } else if (startsWith(eventName, "htmx-")) {            eventName = "htmx:" + eventName.slice(5);          }          addHxOnEventHandler(elt, eventName, value);        }      }    }  }  function initNode(elt) {    if (closest(elt, htmx.config.disableSelector)) {      cleanUpElement(elt);      return;    }    const nodeData = getInternalData(elt);    if (nodeData.initHash !== attributeHash(elt)) {      deInitNode(elt);      nodeData.initHash = attributeHash(elt);      triggerEvent(elt, "htmx:beforeProcessNode");      const triggerSpecs = getTriggerSpecs(elt);      const hasExplicitHttpAction = processVerbs(elt, nodeData, triggerSpecs);      if (!hasExplicitHttpAction) {        if (getClosestAttributeValue(elt, "hx-boost") === "true") {          boostElement(elt, nodeData, triggerSpecs);        } else if (hasAttribute(elt, "hx-trigger")) {          triggerSpecs.forEach(function (triggerSpec) {            addTriggerHandler(elt, triggerSpec, nodeData, function () {});          });        }      }      if (        elt.tagName === "FORM" ||        (getRawAttribute(elt, "type") === "submit" && hasAttribute(elt, "form"))      ) {        initButtonTracking(elt);      }      triggerEvent(elt, "htmx:afterProcessNode");    }  }  function processNode(elt) {    elt = resolveTarget(elt);    if (closest(elt, htmx.config.disableSelector)) {      cleanUpElement(elt);      return;    }    initNode(elt);    forEach(findElementsToProcess(elt), function (child) {      initNode(child);    });    forEach(findHxOnWildcardElements(elt), processHxOnWildcard);  }  function kebabEventName(str) {    return str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();  }  function makeEvent(eventName, detail) {    let evt;    if (window.CustomEvent && typeof window.CustomEvent === "function") {      evt = new CustomEvent(eventName, {        bubbles: true,        cancelable: true,        composed: true,        detail,      });    } else {      evt = getDocument().createEvent("CustomEvent");      evt.initCustomEvent(eventName, true, true, detail);    }    return evt;  }  function triggerErrorEvent(elt, eventName, detail) {    triggerEvent(elt, eventName, mergeObjects({ error: eventName }, detail));  }  function ignoreEventForLogging(eventName) {    return eventName === "htmx:afterProcessNode";  }  function withExtensions(elt, toDo) {    forEach(getExtensions(elt), function (extension) {      try {        toDo(extension);      } catch (e) {        logError(e);      }    });  }  function logError(msg) {    if (console.error) {      console.error(msg);    } else if (console.log) {      console.log("ERROR: ", msg);    }  }  function triggerEvent(elt, eventName, detail) {    elt = resolveTarget(elt);    if (detail == null) {      detail = {};    }    detail.elt = elt;    const event = makeEvent(eventName, detail);    if (htmx.logger && !ignoreEventForLogging(eventName)) {      htmx.logger(elt, eventName, detail);    }    if (detail.error) {      logError(detail.error);      triggerEvent(elt, "htmx:error", { errorInfo: detail });    }    let eventResult = elt.dispatchEvent(event);    const kebabName = kebabEventName(eventName);    if (eventResult && kebabName !== eventName) {      const kebabedEvent = makeEvent(kebabName, event.detail);      eventResult = eventResult && elt.dispatchEvent(kebabedEvent);    }    withExtensions(asElement(elt), function (extension) {      eventResult =        eventResult &&        extension.onEvent(eventName, event) !== false &&        !event.defaultPrevented;    });    return eventResult;  }  let currentPathForHistory = location.pathname + location.search;  function getHistoryElement() {    const historyElt = getDocument().querySelector(      "[hx-history-elt],[data-hx-history-elt]",    );    return historyElt || getDocument().body;  }  function saveToHistoryCache(url, rootElt) {    if (!canAccessLocalStorage()) {      return;    }    const innerHTML = cleanInnerHtmlForHistory(rootElt);    const title = getDocument().title;    const scroll = window.scrollY;    if (htmx.config.historyCacheSize <= 0) {      localStorage.removeItem("htmx-history-cache");      return;    }    url = normalizePath(url);    const historyCache =      parseJSON(localStorage.getItem("htmx-history-cache")) || [];    for (let i = 0; i < historyCache.length; i++) {      if (historyCache[i].url === url) {        historyCache.splice(i, 1);        break;      }    }    const newHistoryItem = { url, content: innerHTML, title, scroll };    triggerEvent(getDocument().body, "htmx:historyItemCreated", {      item: newHistoryItem,      cache: historyCache,    });    historyCache.push(newHistoryItem);    while (historyCache.length > htmx.config.historyCacheSize) {      historyCache.shift();    }    while (historyCache.length > 0) {      try {        localStorage.setItem(          "htmx-history-cache",          JSON.stringify(historyCache),        );        break;      } catch (e) {        triggerErrorEvent(getDocument().body, "htmx:historyCacheError", {          cause: e,          cache: historyCache,        });        historyCache.shift();      }    }  }  function getCachedHistory(url) {    if (!canAccessLocalStorage()) {      return null;    }    url = normalizePath(url);    const historyCache =      parseJSON(localStorage.getItem("htmx-history-cache")) || [];    for (let i = 0; i < historyCache.length; i++) {      if (historyCache[i].url === url) {        return historyCache[i];      }    }    return null;  }  function cleanInnerHtmlForHistory(elt) {    const className = htmx.config.requestClass;    const clone = elt.cloneNode(true);    forEach(findAll(clone, "." + className), function (child) {      removeClassFromElement(child, className);    });    forEach(findAll(clone, "[data-disabled-by-htmx]"), function (child) {      child.removeAttribute("disabled");    });    return clone.innerHTML;  }  function saveCurrentPageToHistory() {    const elt = getHistoryElement();    const path = currentPathForHistory || location.pathname + location.search;    let disableHistoryCache;    try {      disableHistoryCache = getDocument().querySelector(        '[hx-history="false" i],[data-hx-history="false" i]',      );    } catch (e) {      disableHistoryCache = getDocument().querySelector(        '[hx-history="false"],[data-hx-history="false"]',      );    }    if (!disableHistoryCache) {      triggerEvent(getDocument().body, "htmx:beforeHistorySave", {        path,        historyElt: elt,      });      saveToHistoryCache(path, elt);    }    if (htmx.config.historyEnabled)      history.replaceState(        { htmx: true },        getDocument().title,        window.location.href,      );  }  function pushUrlIntoHistory(path) {    if (htmx.config.getCacheBusterParam) {      path = path.replace(/org\.htmx\.cache-buster=[^&]*&?/, "");      if (endsWith(path, "&") || endsWith(path, "?")) {        path = path.slice(0, -1);      }    }    if (htmx.config.historyEnabled) {      history.pushState({ htmx: true }, "", path);    }    currentPathForHistory = path;  }  function replaceUrlInHistory(path) {    if (htmx.config.historyEnabled)      history.replaceState({ htmx: true }, "", path);    currentPathForHistory = path;  }  function settleImmediately(tasks) {    forEach(tasks, function (task) {      task.call(undefined);    });  }  function loadHistoryFromServer(path) {    const request = new XMLHttpRequest();    const details = { path, xhr: request };    triggerEvent(getDocument().body, "htmx:historyCacheMiss", details);    request.open("GET", path, true);    request.setRequestHeader("HX-Request", "true");    request.setRequestHeader("HX-History-Restore-Request", "true");    request.setRequestHeader("HX-Current-URL", getDocument().location.href);    request.onload = function () {      if (this.status >= 200 && this.status < 400) {        triggerEvent(getDocument().body, "htmx:historyCacheMissLoad", details);        const fragment = makeFragment(this.response);        const content =          fragment.querySelector("[hx-history-elt],[data-hx-history-elt]") ||          fragment;        const historyElement = getHistoryElement();        const settleInfo = makeSettleInfo(historyElement);        handleTitle(fragment.title);        handlePreservedElements(fragment);        swapInnerHTML(historyElement, content, settleInfo);        restorePreservedElements();        settleImmediately(settleInfo.tasks);        currentPathForHistory = path;        triggerEvent(getDocument().body, "htmx:historyRestore", {          path,          cacheMiss: true,          serverResponse: this.response,        });      } else {        triggerErrorEvent(          getDocument().body,          "htmx:historyCacheMissLoadError",          details,        );      }    };    request.send();  }  function restoreHistory(path) {    saveCurrentPageToHistory();    path = path || location.pathname + location.search;    const cached = getCachedHistory(path);    if (cached) {      const fragment = makeFragment(cached.content);      const historyElement = getHistoryElement();      const settleInfo = makeSettleInfo(historyElement);      handleTitle(cached.title);      handlePreservedElements(fragment);      swapInnerHTML(historyElement, fragment, settleInfo);      restorePreservedElements();      settleImmediately(settleInfo.tasks);      getWindow().setTimeout(function () {        window.scrollTo(0, cached.scroll);      }, 0);      currentPathForHistory = path;      triggerEvent(getDocument().body, "htmx:historyRestore", {        path,        item: cached,      });    } else {      if (htmx.config.refreshOnHistoryMiss) {        window.location.reload(true);      } else {        loadHistoryFromServer(path);      }    }  }  function addRequestIndicatorClasses(elt) {    let indicators = findAttributeTargets(elt, "hx-indicator");    if (indicators == null) {      indicators = [elt];    }    forEach(indicators, function (ic) {      const internalData = getInternalData(ic);      internalData.requestCount = (internalData.requestCount || 0) + 1;      ic.classList.add.call(ic.classList, htmx.config.requestClass);    });    return indicators;  }  function disableElements(elt) {    let disabledElts = findAttributeTargets(elt, "hx-disabled-elt");    if (disabledElts == null) {      disabledElts = [];    }    forEach(disabledElts, function (disabledElement) {      const internalData = getInternalData(disabledElement);      internalData.requestCount = (internalData.requestCount || 0) + 1;      disabledElement.setAttribute("disabled", "");      disabledElement.setAttribute("data-disabled-by-htmx", "");    });    return disabledElts;  }  function removeRequestIndicators(indicators, disabled) {    forEach(indicators.concat(disabled), function (ele) {      const internalData = getInternalData(ele);      internalData.requestCount = (internalData.requestCount || 1) - 1;    });    forEach(indicators, function (ic) {      const internalData = getInternalData(ic);      if (internalData.requestCount === 0) {        ic.classList.remove.call(ic.classList, htmx.config.requestClass);      }    });    forEach(disabled, function (disabledElement) {      const internalData = getInternalData(disabledElement);      if (internalData.requestCount === 0) {        disabledElement.removeAttribute("disabled");        disabledElement.removeAttribute("data-disabled-by-htmx");      }    });  }  function haveSeenNode(processed, elt) {    for (let i = 0; i < processed.length; i++) {      const node = processed[i];      if (node.isSameNode(elt)) {        return true;      }    }    return false;  }  function shouldInclude(element) {    const elt = element;    if (      elt.name === "" ||      elt.name == null ||      elt.disabled ||      closest(elt, "fieldset[disabled]")    ) {      return false;    }    if (      elt.type === "button" ||      elt.type === "submit" ||      elt.tagName === "image" ||      elt.tagName === "reset" ||      elt.tagName === "file"    ) {      return false;    }    if (elt.type === "checkbox" || elt.type === "radio") {      return elt.checked;    }    return true;  }  function addValueToFormData(name, value, formData) {    if (name != null && value != null) {      if (Array.isArray(value)) {        value.forEach(function (v) {          formData.append(name, v);        });      } else {        formData.append(name, value);      }    }  }  function removeValueFromFormData(name, value, formData) {    if (name != null && value != null) {      let values = formData.getAll(name);      if (Array.isArray(value)) {        values = values.filter((v) => value.indexOf(v) < 0);      } else {        values = values.filter((v) => v !== value);      }      formData.delete(name);      forEach(values, (v) => formData.append(name, v));    }  }  function processInputValue(processed, formData, errors, elt, validate) {    if (elt == null || haveSeenNode(processed, elt)) {      return;    } else {      processed.push(elt);    }    if (shouldInclude(elt)) {      const name = getRawAttribute(elt, "name");      let value = elt.value;      if (elt instanceof HTMLSelectElement && elt.multiple) {        value = toArray(elt.querySelectorAll("option:checked")).map(          function (e) {            return e.value;          },        );      }      if (elt instanceof HTMLInputElement && elt.files) {        value = toArray(elt.files);      }      addValueToFormData(name, value, formData);      if (validate) {        validateElement(elt, errors);      }    }    if (elt instanceof HTMLFormElement) {      forEach(elt.elements, function (input) {        if (processed.indexOf(input) >= 0) {          removeValueFromFormData(input.name, input.value, formData);        } else {          processed.push(input);        }        if (validate) {          validateElement(input, errors);        }      });      new FormData(elt).forEach(function (value, name) {        if (value instanceof File && value.name === "") {          return;        }        addValueToFormData(name, value, formData);      });    }  }  function validateElement(elt, errors) {    const element = elt;    if (element.willValidate) {      triggerEvent(element, "htmx:validation:validate");      if (!element.checkValidity()) {        errors.push({          elt: element,          message: element.validationMessage,          validity: element.validity,        });        triggerEvent(element, "htmx:validation:failed", {          message: element.validationMessage,          validity: element.validity,        });      }    }  }  function overrideFormData(receiver, donor) {    for (const key of donor.keys()) {      receiver.delete(key);    }    donor.forEach(function (value, key) {      receiver.append(key, value);    });    return receiver;  }  function getInputValues(elt, verb) {    const processed = [];    const formData = new FormData();    const priorityFormData = new FormData();    const errors = [];    const internalData = getInternalData(elt);    if (      internalData.lastButtonClicked &&      !bodyContains(internalData.lastButtonClicked)    ) {      internalData.lastButtonClicked = null;    }    let validate =      (elt instanceof HTMLFormElement && elt.noValidate !== true) ||      getAttributeValue(elt, "hx-validate") === "true";    if (internalData.lastButtonClicked) {      validate =        validate && internalData.lastButtonClicked.formNoValidate !== true;    }    if (verb !== "get") {      processInputValue(        processed,        priorityFormData,        errors,        closest(elt, "form"),        validate,      );    }    processInputValue(processed, formData, errors, elt, validate);    if (      internalData.lastButtonClicked ||      elt.tagName === "BUTTON" ||      (elt.tagName === "INPUT" && getRawAttribute(elt, "type") === "submit")    ) {      const button = internalData.lastButtonClicked || elt;      const name = getRawAttribute(button, "name");      addValueToFormData(name, button.value, priorityFormData);    }    const includes = findAttributeTargets(elt, "hx-include");    forEach(includes, function (node) {      processInputValue(processed, formData, errors, asElement(node), validate);      if (!matches(node, "form")) {        forEach(          asParentNode(node).querySelectorAll(INPUT_SELECTOR),          function (descendant) {            processInputValue(              processed,              formData,              errors,              descendant,              validate,            );          },        );      }    });    overrideFormData(formData, priorityFormData);    return { errors, formData, values: formDataProxy(formData) };  }  function appendParam(returnStr, name, realValue) {    if (returnStr !== "") {      returnStr += "&";    }    if (String(realValue) === "[object Object]") {      realValue = JSON.stringify(realValue);    }    const s = encodeURIComponent(realValue);    returnStr += encodeURIComponent(name) + "=" + s;    return returnStr;  }  function urlEncode(values) {    values = formDataFromObject(values);    let returnStr = "";    values.forEach(function (value, key) {      returnStr = appendParam(returnStr, key, value);    });    return returnStr;  }  function getHeaders(elt, target, prompt) {    const headers = {      "HX-Request": "true",      "HX-Trigger": getRawAttribute(elt, "id"),      "HX-Trigger-Name": getRawAttribute(elt, "name"),      "HX-Target": getAttributeValue(target, "id"),      "HX-Current-URL": getDocument().location.href,    };    getValuesForElement(elt, "hx-headers", false, headers);    if (prompt !== undefined) {      headers["HX-Prompt"] = prompt;    }    if (getInternalData(elt).boosted) {      headers["HX-Boosted"] = "true";    }    return headers;  }  function filterValues(inputValues, elt) {    const paramsValue = getClosestAttributeValue(elt, "hx-params");    if (paramsValue) {      if (paramsValue === "none") {        return new FormData();      } else if (paramsValue === "*") {        return inputValues;      } else if (paramsValue.indexOf("not ") === 0) {        forEach(paramsValue.substr(4).split(","), function (name) {          name = name.trim();          inputValues.delete(name);        });        return inputValues;      } else {        const newValues = new FormData();        forEach(paramsValue.split(","), function (name) {          name = name.trim();          if (inputValues.has(name)) {            inputValues.getAll(name).forEach(function (value) {              newValues.append(name, value);            });          }        });        return newValues;      }    } else {      return inputValues;    }  }  function isAnchorLink(elt) {    return (      !!getRawAttribute(elt, "href") &&      getRawAttribute(elt, "href").indexOf("#") >= 0    );  }  function getSwapSpecification(elt, swapInfoOverride) {    const swapInfo =      swapInfoOverride || getClosestAttributeValue(elt, "hx-swap");    const swapSpec = {      swapStyle: getInternalData(elt).boosted        ? "innerHTML"        : htmx.config.defaultSwapStyle,      swapDelay: htmx.config.defaultSwapDelay,      settleDelay: htmx.config.defaultSettleDelay,    };    if (      htmx.config.scrollIntoViewOnBoost &&      getInternalData(elt).boosted &&      !isAnchorLink(elt)    ) {      swapSpec.show = "top";    }    if (swapInfo) {      const split = splitOnWhitespace(swapInfo);      if (split.length > 0) {        for (let i = 0; i < split.length; i++) {          const value = split[i];          if (value.indexOf("swap:") === 0) {            swapSpec.swapDelay = parseInterval(value.substr(5));          } else if (value.indexOf("settle:") === 0) {            swapSpec.settleDelay = parseInterval(value.substr(7));          } else if (value.indexOf("transition:") === 0) {            swapSpec.transition = value.substr(11) === "true";          } else if (value.indexOf("ignoreTitle:") === 0) {            swapSpec.ignoreTitle = value.substr(12) === "true";          } else if (value.indexOf("scroll:") === 0) {            const scrollSpec = value.substr(7);            var splitSpec = scrollSpec.split(":");            const scrollVal = splitSpec.pop();            var selectorVal = splitSpec.length > 0 ? splitSpec.join(":") : null;            swapSpec.scroll = scrollVal;            swapSpec.scrollTarget = selectorVal;          } else if (value.indexOf("show:") === 0) {            const showSpec = value.substr(5);            var splitSpec = showSpec.split(":");            const showVal = splitSpec.pop();            var selectorVal = splitSpec.length > 0 ? splitSpec.join(":") : null;            swapSpec.show = showVal;            swapSpec.showTarget = selectorVal;          } else if (value.indexOf("focus-scroll:") === 0) {            const focusScrollVal = value.substr("focus-scroll:".length);            swapSpec.focusScroll = focusScrollVal == "true";          } else if (i == 0) {            swapSpec.swapStyle = value;          } else {            logError("Unknown modifier in hx-swap: " + value);          }        }      }    }    return swapSpec;  }  function usesFormData(elt) {    return (      getClosestAttributeValue(elt, "hx-encoding") === "multipart/form-data" ||      (matches(elt, "form") &&        getRawAttribute(elt, "enctype") === "multipart/form-data")    );  }  function encodeParamsForBody(xhr, elt, filteredParameters) {    let encodedParameters = null;    withExtensions(elt, function (extension) {      if (encodedParameters == null) {        encodedParameters = extension.encodeParameters(          xhr,          filteredParameters,          elt,        );      }    });    if (encodedParameters != null) {      return encodedParameters;    } else {      if (usesFormData(elt)) {        return overrideFormData(          new FormData(),          formDataFromObject(filteredParameters),        );      } else {        return urlEncode(filteredParameters);      }    }  }  function makeSettleInfo(target) {    return { tasks: [], elts: [target] };  }  function updateScrollState(content, swapSpec) {    const first = content[0];    const last = content[content.length - 1];    if (swapSpec.scroll) {      var target = null;      if (swapSpec.scrollTarget) {        target = asElement(querySelectorExt(first, swapSpec.scrollTarget));      }      if (swapSpec.scroll === "top" && (first || target)) {        target = target || first;        target.scrollTop = 0;      }      if (swapSpec.scroll === "bottom" && (last || target)) {        target = target || last;        target.scrollTop = target.scrollHeight;      }    }    if (swapSpec.show) {      var target = null;      if (swapSpec.showTarget) {        let targetStr = swapSpec.showTarget;        if (swapSpec.showTarget === "window") {          targetStr = "body";        }        target = asElement(querySelectorExt(first, targetStr));      }      if (swapSpec.show === "top" && (first || target)) {        target = target || first;        target.scrollIntoView({          block: "start",          behavior: htmx.config.scrollBehavior,        });      }      if (swapSpec.show === "bottom" && (last || target)) {        target = target || last;        target.scrollIntoView({          block: "end",          behavior: htmx.config.scrollBehavior,        });      }    }  }  function getValuesForElement(elt, attr, evalAsDefault, values) {    if (values == null) {      values = {};    }    if (elt == null) {      return values;    }    const attributeValue = getAttributeValue(elt, attr);    if (attributeValue) {      let str = attributeValue.trim();      let evaluateValue = evalAsDefault;      if (str === "unset") {        return null;      }      if (str.indexOf("javascript:") === 0) {        str = str.substr(11);        evaluateValue = true;      } else if (str.indexOf("js:") === 0) {        str = str.substr(3);        evaluateValue = true;      }      if (str.indexOf("{") !== 0) {        str = "{" + str + "}";      }      let varsValues;      if (evaluateValue) {        varsValues = maybeEval(          elt,          function () {            return Function("return (" + str + ")")();          },          {},        );      } else {        varsValues = parseJSON(str);      }      for (const key in varsValues) {        if (varsValues.hasOwnProperty(key)) {          if (values[key] == null) {            values[key] = varsValues[key];          }        }      }    }    return getValuesForElement(      asElement(parentElt(elt)),      attr,      evalAsDefault,      values,    );  }  function maybeEval(elt, toEval, defaultVal) {    if (htmx.config.allowEval) {      return toEval();    } else {      triggerErrorEvent(elt, "htmx:evalDisallowedError");      return defaultVal;    }  }  function getHXVarsForElement(elt, expressionVars) {    return getValuesForElement(elt, "hx-vars", true, expressionVars);  }  function getHXValsForElement(elt, expressionVars) {    return getValuesForElement(elt, "hx-vals", false, expressionVars);  }  function getExpressionVars(elt) {    return mergeObjects(getHXVarsForElement(elt), getHXValsForElement(elt));  }  function safelySetHeaderValue(xhr, header, headerValue) {    if (headerValue !== null) {      try {        xhr.setRequestHeader(header, headerValue);      } catch (e) {        xhr.setRequestHeader(header, encodeURIComponent(headerValue));        xhr.setRequestHeader(header + "-URI-AutoEncoded", "true");      }    }  }  function getPathFromResponse(xhr) {    if (xhr.responseURL && typeof URL !== "undefined") {      try {        const url = new URL(xhr.responseURL);        return url.pathname + url.search;      } catch (e) {        triggerErrorEvent(getDocument().body, "htmx:badResponseUrl", {          url: xhr.responseURL,        });      }    }  }  function hasHeader(xhr, regexp) {    return regexp.test(xhr.getAllResponseHeaders());  }  function ajaxHelper(verb, path, context) {    verb = verb.toLowerCase();    if (context) {      if (context instanceof Element || typeof context === "string") {        return issueAjaxRequest(verb, path, null, null, {          targetOverride: resolveTarget(context) || DUMMY_ELT,          returnPromise: true,        });      } else {        let resolvedTarget = resolveTarget(context.target);        if (          (context.target && !resolvedTarget) ||          (!resolvedTarget && !resolveTarget(context.source))        ) {          resolvedTarget = DUMMY_ELT;        }        return issueAjaxRequest(          verb,          path,          resolveTarget(context.source),          context.event,          {            handler: context.handler,            headers: context.headers,            values: context.values,            targetOverride: resolvedTarget,            swapOverride: context.swap,            select: context.select,            returnPromise: true,          },        );      }    } else {      return issueAjaxRequest(verb, path, null, null, { returnPromise: true });    }  }  function hierarchyForElt(elt) {    const arr = [];    while (elt) {      arr.push(elt);      elt = elt.parentElement;    }    return arr;  }  function verifyPath(elt, path, requestConfig) {    let sameHost;    let url;    if (typeof URL === "function") {      url = new URL(path, document.location.href);      const origin = document.location.origin;      sameHost = origin === url.origin;    } else {      url = path;      sameHost = startsWith(path, document.location.origin);    }    if (htmx.config.selfRequestsOnly) {      if (!sameHost) {        return false;      }    }    return triggerEvent(      elt,      "htmx:validateUrl",      mergeObjects({ url, sameHost }, requestConfig),    );  }  function formDataFromObject(obj) {    if (obj instanceof FormData) return obj;    const formData = new FormData();    for (const key in obj) {      if (obj.hasOwnProperty(key)) {        if (obj[key] && typeof obj[key].forEach === "function") {          obj[key].forEach(function (v) {            formData.append(key, v);          });        } else if (          typeof obj[key] === "object" &&          !(obj[key] instanceof Blob)        ) {          formData.append(key, JSON.stringify(obj[key]));        } else {          formData.append(key, obj[key]);        }      }    }    return formData;  }  function formDataArrayProxy(formData, name, array) {    return new Proxy(array, {      get: function (target, key) {        if (typeof key === "number") return target[key];        if (key === "length") return target.length;        if (key === "push") {          return function (value) {            target.push(value);            formData.append(name, value);          };        }        if (typeof target[key] === "function") {          return function () {            target[key].apply(target, arguments);            formData.delete(name);            target.forEach(function (v) {              formData.append(name, v);            });          };        }        if (target[key] && target[key].length === 1) {          return target[key][0];        } else {          return target[key];        }      },      set: function (target, index, value) {        target[index] = value;        formData.delete(name);        target.forEach(function (v) {          formData.append(name, v);        });        return true;      },    });  }  function formDataProxy(formData) {    return new Proxy(formData, {      get: function (target, name) {        if (typeof name === "symbol") {          return Reflect.get(target, name);        }        if (name === "toJSON") {          return () => Object.fromEntries(formData);        }        if (name in target) {          if (typeof target[name] === "function") {            return function () {              return formData[name].apply(formData, arguments);            };          } else {            return target[name];          }        }        const array = formData.getAll(name);        if (array.length === 0) {          return undefined;        } else if (array.length === 1) {          return array[0];        } else {          return formDataArrayProxy(target, name, array);        }      },      set: function (target, name, value) {        if (typeof name !== "string") {          return false;        }        target.delete(name);        if (value && typeof value.forEach === "function") {          value.forEach(function (v) {            target.append(name, v);          });        } else if (typeof value === "object" && !(value instanceof Blob)) {          target.append(name, JSON.stringify(value));        } else {          target.append(name, value);        }        return true;      },      deleteProperty: function (target, name) {        if (typeof name === "string") {          target.delete(name);        }        return true;      },      ownKeys: function (target) {        return Reflect.ownKeys(Object.fromEntries(target));      },      getOwnPropertyDescriptor: function (target, prop) {        return Reflect.getOwnPropertyDescriptor(          Object.fromEntries(target),          prop,        );      },    });  }  function issueAjaxRequest(verb, path, elt, event, etc, confirmed) {    let resolve = null;    let reject = null;    etc = etc != null ? etc : {};    if (etc.returnPromise && typeof Promise !== "undefined") {      var promise = new Promise(function (_resolve, _reject) {        resolve = _resolve;        reject = _reject;      });    }    if (elt == null) {      elt = getDocument().body;    }    const responseHandler = etc.handler || handleAjaxResponse;    const select = etc.select || null;    if (!bodyContains(elt)) {      maybeCall(resolve);      return promise;    }    const target = etc.targetOverride || asElement(getTarget(elt));    if (target == null || target == DUMMY_ELT) {      triggerErrorEvent(elt, "htmx:targetError", {        target: getAttributeValue(elt, "hx-target"),      });      maybeCall(reject);      return promise;    }    let eltData = getInternalData(elt);    const submitter = eltData.lastButtonClicked;    if (submitter) {      const buttonPath = getRawAttribute(submitter, "formaction");      if (buttonPath != null) {        path = buttonPath;      }      const buttonVerb = getRawAttribute(submitter, "formmethod");      if (buttonVerb != null) {        if (buttonVerb.toLowerCase() !== "dialog") {          verb = buttonVerb;        }      }    }    const confirmQuestion = getClosestAttributeValue(elt, "hx-confirm");    if (confirmed === undefined) {      const issueRequest = function (skipConfirmation) {        return issueAjaxRequest(          verb,          path,          elt,          event,          etc,          !!skipConfirmation,        );      };      const confirmDetails = {        target,        elt,        path,        verb,        triggeringEvent: event,        etc,        issueRequest,        question: confirmQuestion,      };      if (triggerEvent(elt, "htmx:confirm", confirmDetails) === false) {        maybeCall(resolve);        return promise;      }    }    let syncElt = elt;    let syncStrategy = getClosestAttributeValue(elt, "hx-sync");    let queueStrategy = null;    let abortable = false;    if (syncStrategy) {      const syncStrings = syncStrategy.split(":");      const selector = syncStrings[0].trim();      if (selector === "this") {        syncElt = findThisElement(elt, "hx-sync");      } else {        syncElt = asElement(querySelectorExt(elt, selector));      }      syncStrategy = (syncStrings[1] || "drop").trim();      eltData = getInternalData(syncElt);      if (        syncStrategy === "drop" &&        eltData.xhr &&        eltData.abortable !== true      ) {        maybeCall(resolve);        return promise;      } else if (syncStrategy === "abort") {        if (eltData.xhr) {          maybeCall(resolve);          return promise;        } else {          abortable = true;        }      } else if (syncStrategy === "replace") {        triggerEvent(syncElt, "htmx:abort");      } else if (syncStrategy.indexOf("queue") === 0) {        const queueStrArray = syncStrategy.split(" ");        queueStrategy = (queueStrArray[1] || "last").trim();      }    }    if (eltData.xhr) {      if (eltData.abortable) {        triggerEvent(syncElt, "htmx:abort");      } else {        if (queueStrategy == null) {          if (event) {            const eventData = getInternalData(event);            if (              eventData &&              eventData.triggerSpec &&              eventData.triggerSpec.queue            ) {              queueStrategy = eventData.triggerSpec.queue;            }          }          if (queueStrategy == null) {            queueStrategy = "last";          }        }        if (eltData.queuedRequests == null) {          eltData.queuedRequests = [];        }        if (queueStrategy === "first" && eltData.queuedRequests.length === 0) {          eltData.queuedRequests.push(function () {            issueAjaxRequest(verb, path, elt, event, etc);          });        } else if (queueStrategy === "all") {          eltData.queuedRequests.push(function () {            issueAjaxRequest(verb, path, elt, event, etc);          });        } else if (queueStrategy === "last") {          eltData.queuedRequests = [];          eltData.queuedRequests.push(function () {            issueAjaxRequest(verb, path, elt, event, etc);          });        }        maybeCall(resolve);        return promise;      }    }    const xhr = new XMLHttpRequest();    eltData.xhr = xhr;    eltData.abortable = abortable;    const endRequestLock = function () {      eltData.xhr = null;      eltData.abortable = false;      if (eltData.queuedRequests != null && eltData.queuedRequests.length > 0) {        const queuedRequest = eltData.queuedRequests.shift();        queuedRequest();      }    };    const promptQuestion = getClosestAttributeValue(elt, "hx-prompt");    if (promptQuestion) {      var promptResponse = prompt(promptQuestion);      if (        promptResponse === null ||        !triggerEvent(elt, "htmx:prompt", { prompt: promptResponse, target })      ) {        maybeCall(resolve);        endRequestLock();        return promise;      }    }    if (confirmQuestion && !confirmed) {      if (!confirm(confirmQuestion)) {        maybeCall(resolve);        endRequestLock();        return promise;      }    }    let headers = getHeaders(elt, target, promptResponse);    if (verb !== "get" && !usesFormData(elt)) {      headers["Content-Type"] = "application/x-www-form-urlencoded";    }    if (etc.headers) {      headers = mergeObjects(headers, etc.headers);    }    const results = getInputValues(elt, verb);    let errors = results.errors;    const rawFormData = results.formData;    if (etc.values) {      overrideFormData(rawFormData, formDataFromObject(etc.values));    }    const expressionVars = formDataFromObject(getExpressionVars(elt));    const allFormData = overrideFormData(rawFormData, expressionVars);    let filteredFormData = filterValues(allFormData, elt);    if (htmx.config.getCacheBusterParam && verb === "get") {      filteredFormData.set(        "org.htmx.cache-buster",        getRawAttribute(target, "id") || "true",      );    }    if (path == null || path === "") {      path = getDocument().location.href;    }    const requestAttrValues = getValuesForElement(elt, "hx-request");    const eltIsBoosted = getInternalData(elt).boosted;    let useUrlParams = htmx.config.methodsThatUseUrlParams.indexOf(verb) >= 0;    const requestConfig = {      boosted: eltIsBoosted,      useUrlParams,      formData: filteredFormData,      parameters: formDataProxy(filteredFormData),      unfilteredFormData: allFormData,      unfilteredParameters: formDataProxy(allFormData),      headers,      target,      verb,      errors,      withCredentials:        etc.credentials ||        requestAttrValues.credentials ||        htmx.config.withCredentials,      timeout: etc.timeout || requestAttrValues.timeout || htmx.config.timeout,      path,      triggeringEvent: event,    };    if (!triggerEvent(elt, "htmx:configRequest", requestConfig)) {      maybeCall(resolve);      endRequestLock();      return promise;    }    path = requestConfig.path;    verb = requestConfig.verb;    headers = requestConfig.headers;    filteredFormData = formDataFromObject(requestConfig.parameters);    errors = requestConfig.errors;    useUrlParams = requestConfig.useUrlParams;    if (errors && errors.length > 0) {      triggerEvent(elt, "htmx:validation:halted", requestConfig);      maybeCall(resolve);      endRequestLock();      return promise;    }    const splitPath = path.split("#");    const pathNoAnchor = splitPath[0];    const anchor = splitPath[1];    let finalPath = path;    if (useUrlParams) {      finalPath = pathNoAnchor;      const hasValues = !filteredFormData.keys().next().done;      if (hasValues) {        if (finalPath.indexOf("?") < 0) {          finalPath += "?";        } else {          finalPath += "&";        }        finalPath += urlEncode(filteredFormData);        if (anchor) {          finalPath += "#" + anchor;        }      }    }    if (!verifyPath(elt, finalPath, requestConfig)) {      triggerErrorEvent(elt, "htmx:invalidPath", requestConfig);      maybeCall(reject);      return promise;    }    xhr.open(verb.toUpperCase(), finalPath, true);    xhr.overrideMimeType("text/html");    xhr.withCredentials = requestConfig.withCredentials;    xhr.timeout = requestConfig.timeout;    if (requestAttrValues.noHeaders) {    } else {      for (const header in headers) {        if (headers.hasOwnProperty(header)) {          const headerValue = headers[header];          safelySetHeaderValue(xhr, header, headerValue);        }      }    }    const responseInfo = {      xhr,      target,      requestConfig,      etc,      boosted: eltIsBoosted,      select,      pathInfo: {        requestPath: path,        finalRequestPath: finalPath,        responsePath: null,        anchor,      },    };    xhr.onload = function () {      try {        const hierarchy = hierarchyForElt(elt);        responseInfo.pathInfo.responsePath = getPathFromResponse(xhr);        responseHandler(elt, responseInfo);        if (responseInfo.keepIndicators !== true) {          removeRequestIndicators(indicators, disableElts);        }        triggerEvent(elt, "htmx:afterRequest", responseInfo);        triggerEvent(elt, "htmx:afterOnLoad", responseInfo);        if (!bodyContains(elt)) {          let secondaryTriggerElt = null;          while (hierarchy.length > 0 && secondaryTriggerElt == null) {            const parentEltInHierarchy = hierarchy.shift();            if (bodyContains(parentEltInHierarchy)) {              secondaryTriggerElt = parentEltInHierarchy;            }          }          if (secondaryTriggerElt) {            triggerEvent(              secondaryTriggerElt,              "htmx:afterRequest",              responseInfo,            );            triggerEvent(secondaryTriggerElt, "htmx:afterOnLoad", responseInfo);          }        }        maybeCall(resolve);        endRequestLock();      } catch (e) {        triggerErrorEvent(          elt,          "htmx:onLoadError",          mergeObjects({ error: e }, responseInfo),        );        throw e;      }    };    xhr.onerror = function () {      removeRequestIndicators(indicators, disableElts);      triggerErrorEvent(elt, "htmx:afterRequest", responseInfo);      triggerErrorEvent(elt, "htmx:sendError", responseInfo);      maybeCall(reject);      endRequestLock();    };    xhr.onabort = function () {      removeRequestIndicators(indicators, disableElts);      triggerErrorEvent(elt, "htmx:afterRequest", responseInfo);      triggerErrorEvent(elt, "htmx:sendAbort", responseInfo);      maybeCall(reject);      endRequestLock();    };    xhr.ontimeout = function () {      removeRequestIndicators(indicators, disableElts);      triggerErrorEvent(elt, "htmx:afterRequest", responseInfo);      triggerErrorEvent(elt, "htmx:timeout", responseInfo);      maybeCall(reject);      endRequestLock();    };    if (!triggerEvent(elt, "htmx:beforeRequest", responseInfo)) {      maybeCall(resolve);      endRequestLock();      return promise;    }    var indicators = addRequestIndicatorClasses(elt);    var disableElts = disableElements(elt);    forEach(      ["loadstart", "loadend", "progress", "abort"],      function (eventName) {        forEach([xhr, xhr.upload], function (target) {          target.addEventListener(eventName, function (event) {            triggerEvent(elt, "htmx:xhr:" + eventName, {              lengthComputable: event.lengthComputable,              loaded: event.loaded,              total: event.total,            });          });        });      },    );    triggerEvent(elt, "htmx:beforeSend", responseInfo);    const params = useUrlParams      ? null      : encodeParamsForBody(xhr, elt, filteredFormData);    xhr.send(params);    return promise;  }  function determineHistoryUpdates(elt, responseInfo) {    const xhr = responseInfo.xhr;    let pathFromHeaders = null;    let typeFromHeaders = null;    if (hasHeader(xhr, /HX-Push:/i)) {      pathFromHeaders = xhr.getResponseHeader("HX-Push");      typeFromHeaders = "push";    } else if (hasHeader(xhr, /HX-Push-Url:/i)) {      pathFromHeaders = xhr.getResponseHeader("HX-Push-Url");      typeFromHeaders = "push";    } else if (hasHeader(xhr, /HX-Replace-Url:/i)) {      pathFromHeaders = xhr.getResponseHeader("HX-Replace-Url");      typeFromHeaders = "replace";    }    if (pathFromHeaders) {      if (pathFromHeaders === "false") {        return {};      } else {        return { type: typeFromHeaders, path: pathFromHeaders };      }    }    const requestPath = responseInfo.pathInfo.finalRequestPath;    const responsePath = responseInfo.pathInfo.responsePath;    const pushUrl = getClosestAttributeValue(elt, "hx-push-url");    const replaceUrl = getClosestAttributeValue(elt, "hx-replace-url");    const elementIsBoosted = getInternalData(elt).boosted;    let saveType = null;    let path = null;    if (pushUrl) {      saveType = "push";      path = pushUrl;    } else if (replaceUrl) {      saveType = "replace";      path = replaceUrl;    } else if (elementIsBoosted) {      saveType = "push";      path = responsePath || requestPath;    }    if (path) {      if (path === "false") {        return {};      }      if (path === "true") {        path = responsePath || requestPath;      }      if (responseInfo.pathInfo.anchor && path.indexOf("#") === -1) {        path = path + "#" + responseInfo.pathInfo.anchor;      }      return { type: saveType, path };    } else {      return {};    }  }  function codeMatches(responseHandlingConfig, status) {    var regExp = new RegExp(responseHandlingConfig.code);    return regExp.test(status.toString(10));  }  function resolveResponseHandling(xhr) {    for (var i = 0; i < htmx.config.responseHandling.length; i++) {      var responseHandlingElement = htmx.config.responseHandling[i];      if (codeMatches(responseHandlingElement, xhr.status)) {        return responseHandlingElement;      }    }    return { swap: false };  }  function handleTitle(title) {    if (title) {      const titleElt = find("title");      if (titleElt) {        titleElt.innerHTML = title;      } else {        window.document.title = title;      }    }  }  function handleAjaxResponse(elt, responseInfo) {    const xhr = responseInfo.xhr;    let target = responseInfo.target;    const etc = responseInfo.etc;    const responseInfoSelect = responseInfo.select;    if (!triggerEvent(elt, "htmx:beforeOnLoad", responseInfo)) return;    if (hasHeader(xhr, /HX-Trigger:/i)) {      handleTriggerHeader(xhr, "HX-Trigger", elt);    }    if (hasHeader(xhr, /HX-Location:/i)) {      saveCurrentPageToHistory();      let redirectPath = xhr.getResponseHeader("HX-Location");      var redirectSwapSpec;      if (redirectPath.indexOf("{") === 0) {        redirectSwapSpec = parseJSON(redirectPath);        redirectPath = redirectSwapSpec.path;        delete redirectSwapSpec.path;      }      ajaxHelper("get", redirectPath, redirectSwapSpec).then(function () {        pushUrlIntoHistory(redirectPath);      });      return;    }    const shouldRefresh =      hasHeader(xhr, /HX-Refresh:/i) &&      xhr.getResponseHeader("HX-Refresh") === "true";    if (hasHeader(xhr, /HX-Redirect:/i)) {      responseInfo.keepIndicators = true;      location.href = xhr.getResponseHeader("HX-Redirect");      shouldRefresh && location.reload();      return;    }    if (shouldRefresh) {      responseInfo.keepIndicators = true;      location.reload();      return;    }    if (hasHeader(xhr, /HX-Retarget:/i)) {      if (xhr.getResponseHeader("HX-Retarget") === "this") {        responseInfo.target = elt;      } else {        responseInfo.target = asElement(          querySelectorExt(elt, xhr.getResponseHeader("HX-Retarget")),        );      }    }    const historyUpdate = determineHistoryUpdates(elt, responseInfo);    const responseHandling = resolveResponseHandling(xhr);    const shouldSwap = responseHandling.swap;    let isError = !!responseHandling.error;    let ignoreTitle = htmx.config.ignoreTitle || responseHandling.ignoreTitle;    let selectOverride = responseHandling.select;    if (responseHandling.target) {      responseInfo.target = asElement(        querySelectorExt(elt, responseHandling.target),      );    }    var swapOverride = etc.swapOverride;    if (swapOverride == null && responseHandling.swapOverride) {      swapOverride = responseHandling.swapOverride;    }    if (hasHeader(xhr, /HX-Retarget:/i)) {      if (xhr.getResponseHeader("HX-Retarget") === "this") {        responseInfo.target = elt;      } else {        responseInfo.target = asElement(          querySelectorExt(elt, xhr.getResponseHeader("HX-Retarget")),        );      }    }    if (hasHeader(xhr, /HX-Reswap:/i)) {      swapOverride = xhr.getResponseHeader("HX-Reswap");    }    var serverResponse = xhr.response;    var beforeSwapDetails = mergeObjects(      {        shouldSwap,        serverResponse,        isError,        ignoreTitle,        selectOverride,        swapOverride,      },      responseInfo,    );    if (      responseHandling.event &&      !triggerEvent(target, responseHandling.event, beforeSwapDetails)    )      return;    if (!triggerEvent(target, "htmx:beforeSwap", beforeSwapDetails)) return;    target = beforeSwapDetails.target;    serverResponse = beforeSwapDetails.serverResponse;    isError = beforeSwapDetails.isError;    ignoreTitle = beforeSwapDetails.ignoreTitle;    selectOverride = beforeSwapDetails.selectOverride;    swapOverride = beforeSwapDetails.swapOverride;    responseInfo.target = target;    responseInfo.failed = isError;    responseInfo.successful = !isError;    if (beforeSwapDetails.shouldSwap) {      if (xhr.status === 286) {        cancelPolling(elt);      }      withExtensions(elt, function (extension) {        serverResponse = extension.transformResponse(serverResponse, xhr, elt);      });      if (historyUpdate.type) {        saveCurrentPageToHistory();      }      var swapSpec = getSwapSpecification(elt, swapOverride);      if (!swapSpec.hasOwnProperty("ignoreTitle")) {        swapSpec.ignoreTitle = ignoreTitle;      }      target.classList.add(htmx.config.swappingClass);      let settleResolve = null;      let settleReject = null;      if (responseInfoSelect) {        selectOverride = responseInfoSelect;      }      if (hasHeader(xhr, /HX-Reselect:/i)) {        selectOverride = xhr.getResponseHeader("HX-Reselect");      }      const selectOOB = getClosestAttributeValue(elt, "hx-select-oob");      const select = getClosestAttributeValue(elt, "hx-select");      let doSwap = function () {        try {          if (historyUpdate.type) {            triggerEvent(              getDocument().body,              "htmx:beforeHistoryUpdate",              mergeObjects({ history: historyUpdate }, responseInfo),            );            if (historyUpdate.type === "push") {              pushUrlIntoHistory(historyUpdate.path);              triggerEvent(getDocument().body, "htmx:pushedIntoHistory", {                path: historyUpdate.path,              });            } else {              replaceUrlInHistory(historyUpdate.path);              triggerEvent(getDocument().body, "htmx:replacedInHistory", {                path: historyUpdate.path,              });            }          }          swap(target, serverResponse, swapSpec, {            select: selectOverride || select,            selectOOB,            eventInfo: responseInfo,            anchor: responseInfo.pathInfo.anchor,            contextElement: elt,            afterSwapCallback: function () {              if (hasHeader(xhr, /HX-Trigger-After-Swap:/i)) {                let finalElt = elt;                if (!bodyContains(elt)) {                  finalElt = getDocument().body;                }                handleTriggerHeader(xhr, "HX-Trigger-After-Swap", finalElt);              }            },            afterSettleCallback: function () {              if (hasHeader(xhr, /HX-Trigger-After-Settle:/i)) {                let finalElt = elt;                if (!bodyContains(elt)) {                  finalElt = getDocument().body;                }                handleTriggerHeader(xhr, "HX-Trigger-After-Settle", finalElt);              }              maybeCall(settleResolve);            },          });        } catch (e) {          triggerErrorEvent(elt, "htmx:swapError", responseInfo);          maybeCall(settleReject);          throw e;        }      };      let shouldTransition = htmx.config.globalViewTransitions;      if (swapSpec.hasOwnProperty("transition")) {        shouldTransition = swapSpec.transition;      }      if (        shouldTransition &&        triggerEvent(elt, "htmx:beforeTransition", responseInfo) &&        typeof Promise !== "undefined" &&        document.startViewTransition      ) {        const settlePromise = new Promise(function (_resolve, _reject) {          settleResolve = _resolve;          settleReject = _reject;        });        const innerDoSwap = doSwap;        doSwap = function () {          document.startViewTransition(function () {            innerDoSwap();            return settlePromise;          });        };      }      if (swapSpec.swapDelay > 0) {        getWindow().setTimeout(doSwap, swapSpec.swapDelay);      } else {        doSwap();      }    }    if (isError) {      triggerErrorEvent(        elt,        "htmx:responseError",        mergeObjects(          {            error:              "Response Status Error Code " +              xhr.status +              " from " +              responseInfo.pathInfo.requestPath,          },          responseInfo,        ),      );    }  }  const extensions = {};  function extensionBase() {    return {      init: function (api) {        return null;      },      getSelectors: function () {        return null;      },      onEvent: function (name, evt) {        return true;      },      transformResponse: function (text, xhr, elt) {        return text;      },      isInlineSwap: function (swapStyle) {        return false;      },      handleSwap: function (swapStyle, target, fragment, settleInfo) {        return false;      },      encodeParameters: function (xhr, parameters, elt) {        return null;      },    };  }  function defineExtension(name, extension) {    if (extension.init) {      extension.init(internalAPI);    }    extensions[name] = mergeObjects(extensionBase(), extension);  }  function removeExtension(name) {    delete extensions[name];  }  function getExtensions(elt, extensionsToReturn, extensionsToIgnore) {    if (extensionsToReturn == undefined) {      extensionsToReturn = [];    }    if (elt == undefined) {      return extensionsToReturn;    }    if (extensionsToIgnore == undefined) {      extensionsToIgnore = [];    }    const extensionsForElement = getAttributeValue(elt, "hx-ext");    if (extensionsForElement) {      forEach(extensionsForElement.split(","), function (extensionName) {        extensionName = extensionName.replace(/ /g, "");        if (extensionName.slice(0, 7) == "ignore:") {          extensionsToIgnore.push(extensionName.slice(7));          return;        }        if (extensionsToIgnore.indexOf(extensionName) < 0) {          const extension = extensions[extensionName];          if (extension && extensionsToReturn.indexOf(extension) < 0) {            extensionsToReturn.push(extension);          }        }      });    }    return getExtensions(      asElement(parentElt(elt)),      extensionsToReturn,      extensionsToIgnore,    );  }  var isReady = false;  getDocument().addEventListener("DOMContentLoaded", function () {    isReady = true;  });  function ready(fn) {    if (isReady || getDocument().readyState === "complete") {      fn();    } else {      getDocument().addEventListener("DOMContentLoaded", fn);    }  }  function insertIndicatorStyles() {    if (htmx.config.includeIndicatorStyles !== false) {      const nonceAttribute = htmx.config.inlineStyleNonce        ? ` nonce="${htmx.config.inlineStyleNonce}"`        : "";      getDocument().head.insertAdjacentHTML(        "beforeend",        "<style" +          nonceAttribute +          "> ." +          htmx.config.indicatorClass +          "{opacity:0} ." +          htmx.config.requestClass +          " ." +          htmx.config.indicatorClass +          "{opacity:1; transition: opacity 200ms ease-in;} ." +          htmx.config.requestClass +          "." +          htmx.config.indicatorClass +          "{opacity:1; transition: opacity 200ms ease-in;} </style>",      );    }  }  function getMetaConfig() {    const element = getDocument().querySelector('meta[name="htmx-config"]');    if (element) {      return parseJSON(element.content);    } else {      return null;    }  }  function mergeMetaConfig() {    const metaConfig = getMetaConfig();    if (metaConfig) {      htmx.config = mergeObjects(htmx.config, metaConfig);    }  }  ready(function () {    mergeMetaConfig();    insertIndicatorStyles();    let body = getDocument().body;    processNode(body);    const restoredElts = getDocument().querySelectorAll(      "[hx-trigger='restored'],[data-hx-trigger='restored']",    );    body.addEventListener("htmx:abort", function (evt) {      const target = evt.target;      const internalData = getInternalData(target);      if (internalData && internalData.xhr) {        internalData.xhr.abort();      }    });    const originalPopstate = window.onpopstate      ? window.onpopstate.bind(window)      : null;    window.onpopstate = function (event) {      if (event.state && event.state.htmx) {        restoreHistory();        forEach(restoredElts, function (elt) {          triggerEvent(elt, "htmx:restored", {            document: getDocument(),            triggerEvent,          });        });      } else {        if (originalPopstate) {          originalPopstate(event);        }      }    };    getWindow().setTimeout(function () {      triggerEvent(body, "htmx:load", {});      body = null;    }, 0);  });  return htmx;})();)RAW";
constexpr char const songselectform_html_content[] = R"RAW(<form class="max-w-sm mx-auto" hx-post="/submit-song-select-form" hx-trigger="submit" hx-swap="none">    <label for="song-select" class="block mb-2 text-sm font-medium text-gray-900">Select a song to        play</label>    <select id="song-select" name="song-id"        class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5"        hx-get="/song-select-form-song-info" hx-trigger="load, change" hx-target="#song-info" hx-swap="innerHTML">        {}    </select>    <div id="song-info" class="mt-2">        <!-- Song info will be loaded here -->    </div>    <button type="submit" class="mt-2 bg-blue-500 hover:bg-blue-700 py-1.5 px-3 rounded-md"        hx-indicator="closest form #spinner">        <span class="button-text text-white font-medium">Load song</span>        <svg id="spinner" class="htmx-indicator" width="24" height="24" viewBox="0 0 24 24"            xmlns="http://www.w3.org/2000/svg">            <circle class="spinner_b2T7" cx="4" cy="12" r="3" fill="white" />            <circle class="spinner_b2T7 spinner_YRVV" cx="12" cy="12" r="3" fill="white" />            <circle class="spinner_b2T7 spinner_c9oY" cx="20" cy="12" r="3" fill="white" />        </svg>    </button></form>)RAW";
constexpr char const button_html_content[] = R"RAW(<button hx-post="{}" hx-swap="outerHTML"    class="mt-2 bg-blue-500 hover:bg-blue-700 text-white font-medium py-1.5 px-3 rounded-md">    {}</button>)RAW";
constexpr char const songinfo_html_content[] = R"RAW(<h3 class="text-sm">Selected song:</h3><div class="text-sm text-gray-600">    <p id="title">"{}"</p>    <p id="artist">By {}</p>    <p id="length">{:%M:%S} min</p>    <p id="bpm">{} bpm</p></div>)RAW";
constexpr char const chordselectform_html_content[] = R"RAW(<form class="max-w-sm mx-auto" hx-post="/submit-chord-select-form" hx-trigger="submit" hx-target="#practice-feedback"    hx-swap="innerHTML">    <label for="chord-select" class="block mb-2 text-sm font-medium text-gray-900">Select a chord to        practice</label>    <select id="chord-select" name="chord"        class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">        {}    </select>    <button type="submit" class="mt-2 bg-blue-500 hover:bg-blue-700 py-1.5 px-3 rounded-md"        hx-indicator="closest form #spinner">        <span class="button-text text-white font-medium">Practice chord</span>        <svg id="spinner" class="htmx-indicator" width="24" height="24" viewBox="0 0 24 24"            xmlns="http://www.w3.org/2000/svg">            <circle class="spinner_b2T7" cx="4" cy="12" r="3" fill="white" />            <circle class="spinner_b2T7 spinner_YRVV" cx="12" cy="12" r="3" fill="white" />            <circle class="spinner_b2T7 spinner_c9oY" cx="20" cy="12" r="3" fill="white" />        </svg>    </button>    <div id="practice-results">    </div></form>)RAW";
constexpr char const error_html_content[] = R"RAW(<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative"    role="alert" id="error-alert">    <strong class="font-bold">Error!</strong>    <span class="block sm:inline">{}</span>    <span class="absolute top-0 bottom-0 right-0 px-4 py-3">        <svg class="fill-current h-6 w-6 text-red-500 cursor-pointer" role="button" xmlns="http://www.w3.org/2000/svg"            viewBox="0 0 20 20" hx-on:click="document.getElementById('error-alert').remove()">            <title>Close</title>            <path                d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z" />        </svg>    </span></div>)RAW";
constexpr char const compiled_css_content[] = R"RAW(*, ::before, ::after {  --tw-border-spacing-x: 0;  --tw-border-spacing-y: 0;  --tw-translate-x: 0;  --tw-translate-y: 0;  --tw-rotate: 0;  --tw-skew-x: 0;  --tw-skew-y: 0;  --tw-scale-x: 1;  --tw-scale-y: 1;  --tw-pan-x:  ;  --tw-pan-y:  ;  --tw-pinch-zoom:  ;  --tw-scroll-snap-strictness: proximity;  --tw-gradient-from-position:  ;  --tw-gradient-via-position:  ;  --tw-gradient-to-position:  ;  --tw-ordinal:  ;  --tw-slashed-zero:  ;  --tw-numeric-figure:  ;  --tw-numeric-spacing:  ;  --tw-numeric-fraction:  ;  --tw-ring-inset:  ;  --tw-ring-offset-width: 0px;  --tw-ring-offset-color: #fff;  --tw-ring-color: rgb(59 130 246 / 0.5);  --tw-ring-offset-shadow: 0 0 #0000;  --tw-ring-shadow: 0 0 #0000;  --tw-shadow: 0 0 #0000;  --tw-shadow-colored: 0 0 #0000;  --tw-blur:  ;  --tw-brightness:  ;  --tw-contrast:  ;  --tw-grayscale:  ;  --tw-hue-rotate:  ;  --tw-invert:  ;  --tw-saturate:  ;  --tw-sepia:  ;  --tw-drop-shadow:  ;  --tw-backdrop-blur:  ;  --tw-backdrop-brightness:  ;  --tw-backdrop-contrast:  ;  --tw-backdrop-grayscale:  ;  --tw-backdrop-hue-rotate:  ;  --tw-backdrop-invert:  ;  --tw-backdrop-opacity:  ;  --tw-backdrop-saturate:  ;  --tw-backdrop-sepia:  ;  --tw-contain-size:  ;  --tw-contain-layout:  ;  --tw-contain-paint:  ;  --tw-contain-style:  ;}::backdrop {  --tw-border-spacing-x: 0;  --tw-border-spacing-y: 0;  --tw-translate-x: 0;  --tw-translate-y: 0;  --tw-rotate: 0;  --tw-skew-x: 0;  --tw-skew-y: 0;  --tw-scale-x: 1;  --tw-scale-y: 1;  --tw-pan-x:  ;  --tw-pan-y:  ;  --tw-pinch-zoom:  ;  --tw-scroll-snap-strictness: proximity;  --tw-gradient-from-position:  ;  --tw-gradient-via-position:  ;  --tw-gradient-to-position:  ;  --tw-ordinal:  ;  --tw-slashed-zero:  ;  --tw-numeric-figure:  ;  --tw-numeric-spacing:  ;  --tw-numeric-fraction:  ;  --tw-ring-inset:  ;  --tw-ring-offset-width: 0px;  --tw-ring-offset-color: #fff;  --tw-ring-color: rgb(59 130 246 / 0.5);  --tw-ring-offset-shadow: 0 0 #0000;  --tw-ring-shadow: 0 0 #0000;  --tw-shadow: 0 0 #0000;  --tw-shadow-colored: 0 0 #0000;  --tw-blur:  ;  --tw-brightness:  ;  --tw-contrast:  ;  --tw-grayscale:  ;  --tw-hue-rotate:  ;  --tw-invert:  ;  --tw-saturate:  ;  --tw-sepia:  ;  --tw-drop-shadow:  ;  --tw-backdrop-blur:  ;  --tw-backdrop-brightness:  ;  --tw-backdrop-contrast:  ;  --tw-backdrop-grayscale:  ;  --tw-backdrop-hue-rotate:  ;  --tw-backdrop-invert:  ;  --tw-backdrop-opacity:  ;  --tw-backdrop-saturate:  ;  --tw-backdrop-sepia:  ;  --tw-contain-size:  ;  --tw-contain-layout:  ;  --tw-contain-paint:  ;  --tw-contain-style:  ;}/*! tailwindcss v3.4.13 | MIT License | https://tailwindcss.com*//*1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)*/*,::before,::after {  box-sizing: border-box;  /* 1 */  border-width: 0;  /* 2 */  border-style: solid;  /* 2 */  border-color: #e5e7eb;  /* 2 */}::before,::after {  --tw-content: '';}/*1. Use a consistent sensible line-height in all browsers.2. Prevent adjustments of font size after orientation changes in iOS.3. Use a more readable tab size.4. Use the user's configured `sans` font-family by default.5. Use the user's configured `sans` font-feature-settings by default.6. Use the user's configured `sans` font-variation-settings by default.7. Disable tap highlights on iOS*/html,:host {  line-height: 1.5;  /* 1 */  -webkit-text-size-adjust: 100%;  /* 2 */  -moz-tab-size: 4;  /* 3 */  -o-tab-size: 4;     tab-size: 4;  /* 3 */  font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";  /* 4 */  font-feature-settings: normal;  /* 5 */  font-variation-settings: normal;  /* 6 */  -webkit-tap-highlight-color: transparent;  /* 7 */}/*1. Remove the margin in all browsers.2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.*/body {  margin: 0;  /* 1 */  line-height: inherit;  /* 2 */}/*1. Add the correct height in Firefox.2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)3. Ensure horizontal rules are visible by default.*/hr {  height: 0;  /* 1 */  color: inherit;  /* 2 */  border-top-width: 1px;  /* 3 */}/*Add the correct text decoration in Chrome, Edge, and Safari.*/abbr:where([title]) {  -webkit-text-decoration: underline dotted;          text-decoration: underline dotted;}/*Remove the default font size and weight for headings.*/h1,h2,h3,h4,h5,h6 {  font-size: inherit;  font-weight: inherit;}/*Reset links to optimize for opt-in styling instead of opt-out.*/a {  color: inherit;  text-decoration: inherit;}/*Add the correct font weight in Edge and Safari.*/b,strong {  font-weight: bolder;}/*1. Use the user's configured `mono` font-family by default.2. Use the user's configured `mono` font-feature-settings by default.3. Use the user's configured `mono` font-variation-settings by default.4. Correct the odd `em` font sizing in all browsers.*/code,kbd,samp,pre {  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;  /* 1 */  font-feature-settings: normal;  /* 2 */  font-variation-settings: normal;  /* 3 */  font-size: 1em;  /* 4 */}/*Add the correct font size in all browsers.*/small {  font-size: 80%;}/*Prevent `sub` and `sup` elements from affecting the line height in all browsers.*/sub,sup {  font-size: 75%;  line-height: 0;  position: relative;  vertical-align: baseline;}sub {  bottom: -0.25em;}sup {  top: -0.5em;}/*1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)3. Remove gaps between table borders by default.*/table {  text-indent: 0;  /* 1 */  border-color: inherit;  /* 2 */  border-collapse: collapse;  /* 3 */}/*1. Change the font styles in all browsers.2. Remove the margin in Firefox and Safari.3. Remove default padding in all browsers.*/button,input,optgroup,select,textarea {  font-family: inherit;  /* 1 */  font-feature-settings: inherit;  /* 1 */  font-variation-settings: inherit;  /* 1 */  font-size: 100%;  /* 1 */  font-weight: inherit;  /* 1 */  line-height: inherit;  /* 1 */  letter-spacing: inherit;  /* 1 */  color: inherit;  /* 1 */  margin: 0;  /* 2 */  padding: 0;  /* 3 */}/*Remove the inheritance of text transform in Edge and Firefox.*/button,select {  text-transform: none;}/*1. Correct the inability to style clickable types in iOS and Safari.2. Remove default button styles.*/button,input:where([type='button']),input:where([type='reset']),input:where([type='submit']) {  -webkit-appearance: button;  /* 1 */  background-color: transparent;  /* 2 */  background-image: none;  /* 2 */}/*Use the modern Firefox focus style for all focusable elements.*/:-moz-focusring {  outline: auto;}/*Remove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)*/:-moz-ui-invalid {  box-shadow: none;}/*Add the correct vertical alignment in Chrome and Firefox.*/progress {  vertical-align: baseline;}/*Correct the cursor style of increment and decrement buttons in Safari.*/::-webkit-inner-spin-button,::-webkit-outer-spin-button {  height: auto;}/*1. Correct the odd appearance in Chrome and Safari.2. Correct the outline style in Safari.*/[type='search'] {  -webkit-appearance: textfield;  /* 1 */  outline-offset: -2px;  /* 2 */}/*Remove the inner padding in Chrome and Safari on macOS.*/::-webkit-search-decoration {  -webkit-appearance: none;}/*1. Correct the inability to style clickable types in iOS and Safari.2. Change font properties to `inherit` in Safari.*/::-webkit-file-upload-button {  -webkit-appearance: button;  /* 1 */  font: inherit;  /* 2 */}/*Add the correct display in Chrome and Safari.*/summary {  display: list-item;}/*Removes the default spacing and border for appropriate elements.*/blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre {  margin: 0;}fieldset {  margin: 0;  padding: 0;}legend {  padding: 0;}ol,ul,menu {  list-style: none;  margin: 0;  padding: 0;}/*Reset default styling for dialogs.*/dialog {  padding: 0;}/*Prevent resizing textareas horizontally by default.*/textarea {  resize: vertical;}/*1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)2. Set the default placeholder color to the user's configured gray 400 color.*/input::-moz-placeholder, textarea::-moz-placeholder {  opacity: 1;  /* 1 */  color: #9ca3af;  /* 2 */}input::placeholder,textarea::placeholder {  opacity: 1;  /* 1 */  color: #9ca3af;  /* 2 */}/*Set the default cursor for buttons.*/button,[role="button"] {  cursor: pointer;}/*Make sure disabled buttons don't get the pointer cursor.*/:disabled {  cursor: default;}/*1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)   This can trigger a poorly considered lint error in some tools but is included by design.*/img,svg,video,canvas,audio,iframe,embed,object {  display: block;  /* 1 */  vertical-align: middle;  /* 2 */}/*Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)*/img,video {  max-width: 100%;  height: auto;}/* Make elements with the HTML hidden attribute stay hidden by default */[hidden] {  display: none;}.fixed {  position: fixed;}.absolute {  position: absolute;}.relative {  position: relative;}.sticky {  position: sticky;}.bottom-0 {  bottom: 0px;}.bottom-2 {  bottom: 0.5rem;}.left-1\/2 {  left: 50%;}.right-0 {  right: 0px;}.top-0 {  top: 0px;}.top-0\.5 {  top: 0.125rem;}.z-50 {  z-index: 50;}.m-4 {  margin: 1rem;}.mx-auto {  margin-left: auto;  margin-right: auto;}.mb-2 {  margin-bottom: 0.5rem;}.mb-8 {  margin-bottom: 2rem;}.mt-12 {  margin-top: 3rem;}.mt-2 {  margin-top: 0.5rem;}.mt-4 {  margin-top: 1rem;}.mt-6 {  margin-top: 1.5rem;}.block {  display: block;}.flex {  display: flex;}.table {  display: table;}.h-6 {  height: 1.5rem;}.min-h-screen {  min-height: 100vh;}.w-6 {  width: 1.5rem;}.w-full {  width: 100%;}.max-w-screen-xl {  max-width: 1280px;}.max-w-sm {  max-width: 24rem;}.max-w-xl {  max-width: 36rem;}.-translate-x-1\/2 {  --tw-translate-x: -50%;  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));}.transform {  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));}.cursor-pointer {  cursor: pointer;}.resize {  resize: both;}.flex-col {  flex-direction: column;}.items-center {  align-items: center;}.justify-between {  justify-content: space-between;}.rounded {  border-radius: 0.25rem;}.rounded-lg {  border-radius: 0.5rem;}.rounded-md {  border-radius: 0.375rem;}.border {  border-width: 1px;}.border-gray-300 {  --tw-border-opacity: 1;  border-color: rgb(209 213 219 / var(--tw-border-opacity));}.border-red-400 {  --tw-border-opacity: 1;  border-color: rgb(248 113 113 / var(--tw-border-opacity));}.bg-blue-500 {  --tw-bg-opacity: 1;  background-color: rgb(59 130 246 / var(--tw-bg-opacity));}.bg-gray-50 {  --tw-bg-opacity: 1;  background-color: rgb(249 250 251 / var(--tw-bg-opacity));}.bg-red-100 {  --tw-bg-opacity: 1;  background-color: rgb(254 226 226 / var(--tw-bg-opacity));}.fill-current {  fill: currentColor;}.p-2\.5 {  padding: 0.625rem;}.p-4 {  padding: 1rem;}.px-3 {  padding-left: 0.75rem;  padding-right: 0.75rem;}.px-4 {  padding-left: 1rem;  padding-right: 1rem;}.py-1\.5 {  padding-top: 0.375rem;  padding-bottom: 0.375rem;}.py-3 {  padding-top: 0.75rem;  padding-bottom: 0.75rem;}.text-center {  text-align: center;}.text-2xl {  font-size: 1.5rem;  line-height: 2rem;}.text-3xl {  font-size: 1.875rem;  line-height: 2.25rem;}.text-lg {  font-size: 1.125rem;  line-height: 1.75rem;}.text-sm {  font-size: 0.875rem;  line-height: 1.25rem;}.font-bold {  font-weight: 700;}.font-medium {  font-weight: 500;}.font-semibold {  font-weight: 600;}.text-gray-500 {  --tw-text-opacity: 1;  color: rgb(107 114 128 / var(--tw-text-opacity));}.text-gray-600 {  --tw-text-opacity: 1;  color: rgb(75 85 99 / var(--tw-text-opacity));}.text-gray-900 {  --tw-text-opacity: 1;  color: rgb(17 24 39 / var(--tw-text-opacity));}.text-red-500 {  --tw-text-opacity: 1;  color: rgb(239 68 68 / var(--tw-text-opacity));}.text-red-700 {  --tw-text-opacity: 1;  color: rgb(185 28 28 / var(--tw-text-opacity));}.text-white {  --tw-text-opacity: 1;  color: rgb(255 255 255 / var(--tw-text-opacity));}.shadow {  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);}.filter {  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);}.transition {  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);  transition-duration: 150ms;}.\[a-zA-Z\:\\-\\\.\] {  a-z-a--z: \-\.;}div.maxwidthcontainer {  margin-left: auto;  margin-right: auto;  width: 100%;  max-width: 1280px;  /* max-w-screen-xl */  padding-left: 10px;  /* px-2.5 (2.5 * 4px = 10px) */  padding-right: 10px;  /* px-2.5 (2.5 * 4px = 10px) */}@media (min-width: 768px) {  /* md breakpoint */  div.maxwidthcontainer {    padding-left: 80px;    /* md:px-20 (20 * 4px = 80px) */    padding-right: 80px;    /* md:px-20 (20 * 4px = 80px) */  }}.htmx-indicator {  display: none;}.htmx-request .htmx-indicator {  display: inline-block;}.htmx-request .button-text {  display: none;}.spinner_b2T7 {  animation: spinner_xe7Q 0.8s linear infinite;}.spinner_YRVV {  animation-delay: -0.65s;}.spinner_c9oY {  animation-delay: -0.5s;}@keyframes spinner_xe7Q {  93.75%,  100% {    r: 3px;  }  46.875% {    r: 0.2px;  }}.hover\:bg-blue-700:hover {  --tw-bg-opacity: 1;  background-color: rgb(29 78 216 / var(--tw-bg-opacity));}.focus\:border-blue-500:focus {  --tw-border-opacity: 1;  border-color: rgb(59 130 246 / var(--tw-border-opacity));}.focus\:ring-blue-500:focus {  --tw-ring-opacity: 1;  --tw-ring-color: rgb(59 130 246 / var(--tw-ring-opacity));}@media (min-width: 640px) {  .sm\:inline {    display: inline;  }})RAW";
constexpr char const htmx_sse_js_content[] = R"RAW((function () {  var api;  htmx.defineExtension("sse", {    init: function (apiRef) {      api = apiRef;      if (htmx.createEventSource == undefined) {        htmx.createEventSource = createEventSource;      }    },    getSelectors: function () {      return [        "[sse-connect]",        "[data-sse-connect]",        "[sse-swap]",        "[data-sse-swap]",      ];    },    onEvent: function (name, evt) {      var parent = evt.target || evt.detail.elt;      switch (name) {        case "htmx:beforeCleanupElement":          var internalData = api.getInternalData(parent);          var source = internalData.sseEventSource;          if (source) {            api.triggerEvent(parent, "htmx:sseClose", {              source,              type: "nodeReplaced",            });            internalData.sseEventSource.close();          }          return;        case "htmx:afterProcessNode":          ensureEventSourceOnElement(parent);      }    },  });  function createEventSource(url) {    return new EventSource(url, { withCredentials: true });  }  function registerSSE(elt) {    if (api.getAttributeValue(elt, "sse-swap")) {      var sourceElement = api.getClosestMatch(elt, hasEventSource);      if (sourceElement == null) {        return null;      }      var internalData = api.getInternalData(sourceElement);      var source = internalData.sseEventSource;      var sseSwapAttr = api.getAttributeValue(elt, "sse-swap");      var sseEventNames = sseSwapAttr.split(",");      for (var i = 0; i < sseEventNames.length; i++) {        const sseEventName = sseEventNames[i].trim();        const listener = function (event) {          if (maybeCloseSSESource(sourceElement)) {            return;          }          if (!api.bodyContains(elt)) {            source.removeEventListener(sseEventName, listener);            return;          }          if (!api.triggerEvent(elt, "htmx:sseBeforeMessage", event)) {            return;          }          swap(elt, event.data);          api.triggerEvent(elt, "htmx:sseMessage", event);        };        api.getInternalData(elt).sseEventListener = listener;        source.addEventListener(sseEventName, listener);      }    }    if (api.getAttributeValue(elt, "hx-trigger")) {      var sourceElement = api.getClosestMatch(elt, hasEventSource);      if (sourceElement == null) {        return null;      }      var internalData = api.getInternalData(sourceElement);      var source = internalData.sseEventSource;      var triggerSpecs = api.getTriggerSpecs(elt);      triggerSpecs.forEach(function (ts) {        if (ts.trigger.slice(0, 4) !== "sse:") {          return;        }        var listener = function (event) {          if (maybeCloseSSESource(sourceElement)) {            return;          }          if (!api.bodyContains(elt)) {            source.removeEventListener(ts.trigger.slice(4), listener);          }          htmx.trigger(elt, ts.trigger, event);          htmx.trigger(elt, "htmx:sseMessage", event);        };        api.getInternalData(elt).sseEventListener = listener;        source.addEventListener(ts.trigger.slice(4), listener);      });    }  }  function ensureEventSourceOnElement(elt, retryCount) {    if (elt == null) {      return null;    }    if (api.getAttributeValue(elt, "sse-connect")) {      var sseURL = api.getAttributeValue(elt, "sse-connect");      if (sseURL == null) {        return;      }      ensureEventSource(elt, sseURL, retryCount);    }    registerSSE(elt);  }  function ensureEventSource(elt, url, retryCount) {    var source = htmx.createEventSource(url);    source.onerror = function (err) {      api.triggerErrorEvent(elt, "htmx:sseError", { error: err, source });      if (maybeCloseSSESource(elt)) {        return;      }      if (source.readyState === EventSource.CLOSED) {        retryCount = retryCount || 0;        retryCount = Math.max(Math.min(retryCount * 2, 128), 1);        var timeout = retryCount * 500;        window.setTimeout(function () {          ensureEventSourceOnElement(elt, retryCount);        }, timeout);      }    };    source.onopen = function (evt) {      api.triggerEvent(elt, "htmx:sseOpen", { source });      if (retryCount && retryCount > 0) {        const childrenToFix = elt.querySelectorAll(          "[sse-swap], [data-sse-swap], [hx-trigger], [data-hx-trigger]",        );        for (let i = 0; i < childrenToFix.length; i++) {          registerSSE(childrenToFix[i]);        }        retryCount = 0;      }    };    api.getInternalData(elt).sseEventSource = source;    var closeAttribute = api.getAttributeValue(elt, "sse-close");    if (closeAttribute) {      source.addEventListener(closeAttribute, function () {        api.triggerEvent(elt, "htmx:sseClose", {          source,          type: "message",        });        source.close();      });    }  }  function maybeCloseSSESource(elt) {    if (!api.bodyContains(elt)) {      var source = api.getInternalData(elt).sseEventSource;      if (source != undefined) {        api.triggerEvent(elt, "htmx:sseClose", {          source,          type: "nodeMissing",        });        source.close();        return true;      }    }    return false;  }  function swap(elt, content) {    api.withExtensions(elt, function (extension) {      content = extension.transformResponse(content, null, elt);    });    var swapSpec = api.getSwapSpecification(elt);    var target = api.getTarget(elt);    api.swap(target, content, swapSpec);  }  function hasEventSource(node) {    return api.getInternalData(node).sseEventSource != null;  }})();)RAW";
constexpr char const style_css_content[] = R"RAW(@tailwind base;@tailwind components;@tailwind utilities;div.maxwidthcontainer {  margin-left: auto;  margin-right: auto;  width: 100%;  max-width: 1280px; /* max-w-screen-xl */  padding-left: 10px; /* px-2.5 (2.5 * 4px = 10px) */  padding-right: 10px; /* px-2.5 (2.5 * 4px = 10px) */}@media (min-width: 768px) {  /* md breakpoint */  div.maxwidthcontainer {    padding-left: 80px; /* md:px-20 (20 * 4px = 80px) */    padding-right: 80px; /* md:px-20 (20 * 4px = 80px) */  }}.htmx-indicator {  display: none;}.htmx-request .htmx-indicator {  display: inline-block;}.htmx-request .button-text {  display: none;}.spinner_b2T7 {  animation: spinner_xe7Q 0.8s linear infinite;}.spinner_YRVV {  animation-delay: -0.65s;}.spinner_c9oY {  animation-delay: -0.5s;}@keyframes spinner_xe7Q {  93.75%,  100% {    r: 3px;  }  46.875% {    r: 0.2px;  }})RAW";
#define SOURCE_FILES_ITER(_F, ...)\
_F(INDEX_HTML, index_html_content, "index.html", __VA_ARGS__)\
_F(HTMX_MIN_JS, htmx_min_js_content, "htmx.min.js", __VA_ARGS__)\
_F(HTMX_RT_JS, htmx_rt_js_content, "htmx.rt.js", __VA_ARGS__)\
_F(HTMX_JS, htmx_js_content, "htmx.js", __VA_ARGS__)\
_F(SONGSELECTFORM_HTML, songselectform_html_content, "songselectform.html", __VA_ARGS__)\
_F(BUTTON_HTML, button_html_content, "button.html", __VA_ARGS__)\
_F(SONGINFO_HTML, songinfo_html_content, "songinfo.html", __VA_ARGS__)\
_F(CHORDSELECTFORM_HTML, chordselectform_html_content, "chordselectform.html", __VA_ARGS__)\
_F(ERROR_HTML, error_html_content, "error.html", __VA_ARGS__)\
_F(COMPILED_CSS, compiled_css_content, "compiled.css", __VA_ARGS__)\
_F(HTMX_SSE_JS, htmx_sse_js_content, "htmx.sse.js", __VA_ARGS__)\
_F(STYLE_CSS, style_css_content, "style.css", __VA_ARGS__)\

} // namespace web
